<!DOCTYPE HTML>
<html class="hljs">
<head>
  <meta
    name="viewport"
    charset="utf-8"
    content="width=device-width, initial-scale=1, user-scalable=no">
  <style>
/*! CodeSlide slides.vertical.css */
html, body {
  margin: 0;
  -webkit-print-color-adjust: exact;
  print-color-adjust: exact;
  overflow: hidden;
}
pre {
  margin: 0;
  white-space: pre-wrap;
  word-break: break-word;
}
#slides {
  display: flex;
  flex-direction: column;
  position: absolute; /* fix height on mobile */
  width: 100vw;
  height: 100vh;
  overflow: scroll;
}
.slide > .title.bordered {
  border-top: thin solid currentColor;
}
.slide > .title {
  font-size: larger;
  font-weight: bolder;
}
@page {
  margin: 0;
  size: auto;
}
@media print {
  #slides {
    width: auto;
    height: auto;
  }
}

pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}/*!
  Theme: GitHub Dark Dimmed
  Description: Dark dimmed theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Colors taken from GitHub's CSS
*/.hljs{color:#adbac7;background:#22272e}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#f47067}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#dcbdfb}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-variable{color:#6cb6ff}.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#96d0ff}.hljs-built_in,.hljs-symbol{color:#f69d50}.hljs-code,.hljs-comment,.hljs-formula{color:#768390}.hljs-name,.hljs-quote,.hljs-selector-pseudo,.hljs-selector-tag{color:#8ddb8c}.hljs-subst{color:#adbac7}.hljs-section{color:#316dca;font-weight:700}.hljs-bullet{color:#eac55f}.hljs-emphasis{color:#adbac7;font-style:italic}.hljs-strong{color:#adbac7;font-weight:700}.hljs-addition{color:#b4f1b4;background-color:#1b4721}.hljs-deletion{color:#ffd8d3;background-color:#78191b}
@font-face {
  font-family: 'Source Code Pro';
  font-style: normal;
  font-weight: 300;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/sourcecodepro/v22/HI_diYsKILxRpg3hIP6sJ7fM7PqPMcMnZFqUwX28DJKQhM4.ttf) format('truetype');
}
@font-face {
  font-family: 'Source Code Pro';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/sourcecodepro/v22/HI_diYsKILxRpg3hIP6sJ7fM7PqPMcMnZFqUwX28DMyQhM4.ttf) format('truetype');
}
@font-face {
  font-family: 'Source Code Pro';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/sourcecodepro/v22/HI_diYsKILxRpg3hIP6sJ7fM7PqPMcMnZFqUwX28DCuXhM4.ttf) format('truetype');
}

/* Tomorrow Night Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */

/* Tomorrow Comment */
.hljs-comment {
  color: #969896;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-attribute,
.hljs-tag,
.hljs-regexp,
.ruby .hljs-constant,
.xml .hljs-tag .hljs-title,
.xml .hljs-pi,
.xml .hljs-doctype,
.html .hljs-doctype,
.css .hljs-id,
.css .hljs-class,
.css .hljs-pseudo {
  color: #cc6666;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-preprocessor,
.hljs-pragma,
.hljs-built_in,
.hljs-literal,
.hljs-params,
.hljs-constant {
  color: #de935f;
}

/* Tomorrow Yellow */
.ruby .hljs-class .hljs-title,
.css .hljs-rule .hljs-attribute {
  color: #f0c674;
}

/* Tomorrow Green */
.hljs-string,
.hljs-value,
.hljs-inheritance,
.hljs-header,
.hljs-name,
.ruby .hljs-symbol,
.xml .hljs-cdata {
  color: #b5bd68;
}

/* Tomorrow Aqua */
.hljs-title,
.css .hljs-hexcolor {
  color: #8abeb7;
}

/* Tomorrow Blue */
.hljs-function,
.python .hljs-decorator,
.python .hljs-title,
.ruby .hljs-function .hljs-title,
.ruby .hljs-title .hljs-keyword,
.perl .hljs-sub,
.javascript .hljs-title,
.coffeescript .hljs-title {
  color: #81a2be;
}

/* Tomorrow Purple */
.hljs-keyword,
.javascript .hljs-function {
  color: #b294bb;
}

.hljs {
  display: block;
  overflow-x: auto;
  background: #1d1f21;
  color: #c5c8c6;
}

.coffeescript .javascript,
.javascript .xml,
.tex .hljs-formula,
.xml .javascript,
.xml .vbscript,
.xml .css,
.xml .hljs-cdata {
  opacity: 0.5;
}

.hljs-addition {
  color: #718c00;
}

.hljs-deletion {
  color: #c82829;
}

code { font-family: Source Code Pro, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace; }
#slides { font-size: large; }
#slides { font-weight: normal; }
  </style>
</head>
<body class="hljs">
  <div id="slides">
    <div class="slide" id="_0" hidden>
      <div class="title">
        <pre><code class="language-plaintext hljs">This is an example of CodeSlide CLI</code></pre>
      </div>
    </div>
    <div class="slide" id="_1" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">rustlings is at https://github.com/rust-lang/rustlings</code></pre>
      </div>
    </div>
    <div class="slide" id="_2" hidden>
      <div class="code">
        <pre><code class="language-markdown"># rustlings ü¶Ä‚ù§Ô∏è

Greetings and welcome to `rustlings`. This project contains small exercises to get you used to reading and writing Rust code. This includes reading and responding to compiler messages!

_...looking for the old, web-based version of Rustlings? Try [here](https://github.com/rust-lang/rustlings/tree/rustlings-1)_

Alternatively, for a first-time Rust learner, there are several other resources:

- [The Book](https://doc.rust-lang.org/book/index.html) - The most comprehensive resource for learning Rust, but a bit theoretical sometimes. You will be using this along with Rustlings!
- [Rust By Example](https://doc.rust-lang.org/rust-by-example/index.html) - Learn Rust by solving little exercises! It&#39;s almost like `rustlings`, but online

## Getting Started

_Note: If you&#39;re on MacOS, make sure you&#39;ve installed Xcode and its developer tools by typing `xcode-select --install`._
_Note: If you&#39;re on Linux, make sure you&#39;ve installed gcc. Deb: `sudo apt install gcc`. Yum: `sudo yum -y install gcc`._

You will need to have Rust installed. You can get it by visiting https://rustup.rs. This&#39;ll also install Cargo, Rust&#39;s package/project manager.

## MacOS/Linux

Just run:

```bash
curl -L https://raw.githubusercontent.com/rust-lang/rustlings/main/install.sh | bash
```
Or if you want it to be installed to a different path:

```bash
curl -L https://raw.githubusercontent.com/rust-lang/rustlings/main/install.sh | bash -s mypath/
```

This will install Rustlings and give you access to the `rustlings` command. Run it to get started!

### Nix

Basically: Clone the repository at the latest tag, finally run `nix develop` or `nix-shell`.

```bash
# find out the latest version at https://github.com/rust-lang/rustlings/releases/latest (on edit 5.4.1)
git clone -b 5.4.1 --depth 1 https://github.com/rust-lang/rustlings
cd rustlings
# if nix version &gt; 2.3
nix develop
# if nix version &lt;= 2.3
nix-shell
```

## Windows

In PowerShell (Run as Administrator), set `ExecutionPolicy` to `RemoteSigned`:

```ps1
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
```

Then, you can run:

```ps1
Start-BitsTransfer -Source https://raw.githubusercontent.com/rust-lang/rustlings/main/install.ps1 -Destination $env:TMP/install_rustlings.ps1; Unblock-File $env:TMP/install_rustlings.ps1; Invoke-Expression $env:TMP/install_rustlings.ps1
```

To install Rustlings. Same as on MacOS/Linux, you will have access to the `rustlings` command after it. Keep in mind that this works best in PowerShell, and any other terminals may give you errors.

If you get a permission denied message, you might have to exclude the directory where you cloned Rustlings in your antivirus.

## Browser

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/rust-lang/rustlings)

[![Open Rustlings On Codespaces](https://github.com/codespaces/badge.svg)](https://github.com/codespaces/new/?repo=rust-lang%2Frustlings&amp;ref=main)

## Manually

Basically: Clone the repository at the latest tag, run `cargo install --path .`.

```bash
# find out the latest version at https://github.com/rust-lang/rustlings/releases/latest (on edit 5.4.1)
git clone -b 5.4.1 --depth 1 https://github.com/rust-lang/rustlings
cd rustlings
cargo install --force --path .
```

If there are installation errors, ensure that your toolchain is up to date. For the latest, run:

```bash
rustup update
```

Then, same as above, run `rustlings` to get started.

## Doing exercises

The exercises are sorted by topic and can be found in the subdirectory `rustlings/exercises/&lt;topic&gt;`. For every topic there is an additional README file with some resources to get you started on the topic. We really recommend that you have a look at them before you start.

The task is simple. Most exercises contain an error that keeps them from compiling, and it&#39;s up to you to fix it! Some exercises are also run as tests, but rustlings handles them all the same. To run the exercises in the recommended order, execute:

```bash
rustlings watch
```

This will try to verify the completion of every exercise in a predetermined order (what we think is best for newcomers). It will also rerun automatically every time you change a file in the `exercises/` directory. If you want to only run it once, you can use:

```bash
rustlings verify
```

This will do the same as watch, but it&#39;ll quit after running.

In case you want to go by your own order, or want to only verify a single exercise, you can run:

```bash
rustlings run myExercise1
```

Or simply use the following command to run the next unsolved exercise in the course:

```bash
rustlings run next
```

In case you get stuck, you can run the following command to get a hint for your
exercise:

```bash
rustlings hint myExercise1
```

You can also get the hint for the next unsolved exercise with the following command:

```bash
rustlings hint next
```

To check your progress, you can run the following command:

```bash
rustlings list
```

## Testing yourself

After every couple of sections, there will be a quiz that&#39;ll test your knowledge on a bunch of sections at once. These quizzes are found in `exercises/quizN.rs`.

## Enabling `rust-analyzer`

Run the command `rustlings lsp` which will generate a `rust-project.json` at the root of the project, this allows [rust-analyzer](https://rust-analyzer.github.io/) to parse each exercise.

## Continuing On

Once you&#39;ve completed Rustlings, put your new knowledge to good use! Continue practicing your Rust skills by building your own projects, contributing to Rustlings, or finding other open-source projects to contribute to.

## Uninstalling Rustlings

If you want to remove Rustlings from your system, there are two steps. First, you&#39;ll need to remove the exercises folder that the install script created
for you:

```bash
rm -rf rustlings # or your custom folder name, if you chose and or renamed it
```

Second, run `cargo uninstall` to remove the `rustlings` binary:

```bash
cargo uninstall rustlings
```

Now you should be done!

## Contributing

See [CONTRIBUTING.md](./CONTRIBUTING.md).

Development-focused discussion about Rustlings happens in the [**rustlings** stream](https://rust-lang.zulipchat.com/#narrow/stream/334454-rustlings)
on the [Rust Project Zulip](https://rust-lang.zulipchat.com). Feel free to start a new thread there
if you have ideas or suggestions!

## Contributors ‚ú®

Thanks goes to the wonderful people listed in [AUTHORS.md](./AUTHORS.md) üéâ
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_3" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Variables

In Rust, variables are immutable by default.
When a variable is immutable, once a value is bound to a name, you can‚Äôt change that value.
You can make them mutable by adding `mut` in front of the variable name.

## Further information

- [Variables and Mutability](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_4" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Variables 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// variables1.rs
// Make me compile!
// Execute `rustlings hint variables1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    x = 5;
    println!(&quot;x has the value {}&quot;, x);
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_5" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Variables 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// variables2.rs
// Execute `rustlings hint variables2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let x;
    if x == 10 {
        println!(&quot;x is ten!&quot;);
    } else {
        println!(&quot;x is not ten!&quot;);
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_6" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Functions

Here, you&#39;ll learn how to write functions and how the Rust compiler can help you debug errors even
in more complex code.

## Further information

- [How Functions Work](https://doc.rust-lang.org/book/ch03-03-how-functions-work.html)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_7" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Functions 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// functions1.rs
// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    call_me();
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_8" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Functions 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// functions2.rs
// Execute `rustlings hint functions2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    call_me(3);
}

fn call_me(num:) {
    for i in 0..num {
        println!(&quot;Ring! Call number {}&quot;, i + 1);
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_9" hidden>
      <div class="code">
        <pre><code class="language-markdown"># If

`if`, the most basic (but still surprisingly versatile!) type of control flow, is what you&#39;ll learn here.

## Further information

- [Control Flow - if expressions](https://doc.rust-lang.org/book/ch03-05-control-flow.html#if-expressions)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_10" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">If 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// if1.rs
// Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

pub fn bigger(a: i32, b: i32) -&gt; i32 {
    // Complete this function to return the bigger number!
    // Do not use:
    // - another function call
    // - additional variables
}

// Don&#39;t mind this for now :)
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ten_is_bigger_than_eight() {
        assert_eq!(10, bigger(10, 8));
    }

    #[test]
    fn fortytwo_is_bigger_than_thirtytwo() {
        assert_eq!(42, bigger(32, 42));
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_11" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">If 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// if2.rs

// Step 1: Make me compile!
// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!
// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

pub fn foo_if_fizz(fizzish: &amp;str) -&gt; &amp;str {
    if fizzish == &quot;fizz&quot; {
        &quot;foo&quot;
    } else {
        1
    }
}

// No test changes needed!
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn foo_for_fizz() {
        assert_eq!(foo_if_fizz(&quot;fizz&quot;), &quot;foo&quot;)
    }

    #[test]
    fn bar_for_fuzz() {
        assert_eq!(foo_if_fizz(&quot;fuzz&quot;), &quot;bar&quot;)
    }

    #[test]
    fn default_to_baz() {
        assert_eq!(foo_if_fizz(&quot;literally anything&quot;), &quot;baz&quot;)
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_12" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Primitive Types

Rust has a couple of basic types that are directly implemented into the
compiler. In this section, we&#39;ll go through the most important ones.

## Further information

- [Data Types](https://doc.rust-lang.org/stable/book/ch03-02-data-types.html)
- [The Slice Type](https://doc.rust-lang.org/stable/book/ch04-03-slices.html)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_13" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Primitive Types 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// primitive_types1.rs
// Fill in the rest of the line that has code missing!
// No hints, there&#39;s no tricks, just get used to typing these :)

// I AM NOT DONE

fn main() {
    // Booleans (`bool`)

    let is_morning = true;
    if is_morning {
        println!(&quot;Good morning!&quot;);
    }

    let // Finish the rest of this line like the example! Or make it be false!
    if is_evening {
        println!(&quot;Good evening!&quot;);
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_14" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Primitive Types 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// primitive_types2.rs
// Fill in the rest of the line that has code missing!
// No hints, there&#39;s no tricks, just get used to typing these :)

// I AM NOT DONE

fn main() {
    // Characters (`char`)

    // Note the _single_ quotes, these are different from the double quotes
    // you&#39;ve been seeing around.
    let my_first_initial = &#39;C&#39;;
    if my_first_initial.is_alphabetic() {
        println!(&quot;Alphabetical!&quot;);
    } else if my_first_initial.is_numeric() {
        println!(&quot;Numerical!&quot;);
    } else {
        println!(&quot;Neither alphabetic nor numeric!&quot;);
    }

    let // Finish this line like the example! What&#39;s your favorite character?
    // Try a letter, try a number, try a special character, try a character
    // from a different language than your own, try an emoji!
    if your_character.is_alphabetic() {
        println!(&quot;Alphabetical!&quot;);
    } else if your_character.is_numeric() {
        println!(&quot;Numerical!&quot;);
    } else {
        println!(&quot;Neither alphabetic nor numeric!&quot;);
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_15" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Vectors

Vectors are one of the most-used Rust data structures. In other programming
languages, they&#39;d simply be called Arrays, but since Rust operates on a
bit of a lower level, an array in Rust is stored on the stack (meaning it
can&#39;t grow or shrink, and the size needs to be known at compile time),
and a Vector is stored in the heap (where these restrictions do not apply).

Vectors are a bit of a later chapter in the book, but we think that they&#39;re
useful enough to talk about them a bit earlier. We shall be talking about
the other useful data structure, hash maps, later.

## Further information

- [Storing Lists of Values with Vectors](https://doc.rust-lang.org/stable/book/ch08-01-vectors.html)
- [`iter_mut`](https://doc.rust-lang.org/std/primitive.slice.html#method.iter_mut)
- [`map`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_16" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Vecs 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// vecs1.rs
// Your task is to create a `Vec` which holds the exact same elements
// as in the array `a`.
// Make me compile and pass the test!
// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn array_and_vec() -&gt; ([i32; 4], Vec&lt;i32&gt;) {
    let a = [10, 20, 30, 40]; // a plain array
    let v = // TODO: declare your vector here with the macro for vectors

    (a, v)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_array_and_vec_similarity() {
        let (a, v) = array_and_vec();
        assert_eq!(a, v[..]);
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_17" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Vecs 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// vecs2.rs
// A Vec of even numbers is given. Your task is to complete the loop
// so that each number in the Vec is multiplied by 2.
//
// Make me pass the test!
//
// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn vec_loop(mut v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    for element in v.iter_mut() {
        // TODO: Fill this up so that each element in the Vec `v` is
        // multiplied by 2.
        ???
    }

    // At this point, `v` should be equal to [4, 8, 12, 16, 20].
    v
}

fn vec_map(v: &amp;Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    v.iter().map(|element| {
        // TODO: Do the same thing as above - but instead of mutating the
        // Vec, you can just return the new number!
        ???
    }).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vec_loop() {
        let v: Vec&lt;i32&gt; = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_loop(v.clone());

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;());
    }

    #[test]
    fn test_vec_map() {
        let v: Vec&lt;i32&gt; = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_map(&amp;v);

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;());
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_18" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Move Semantics

These exercises are adapted from [pnkfelix](https://github.com/pnkfelix)&#39;s [Rust Tutorial](https://pnkfelix.github.io/rust-examples-icfp2014/) -- Thank you Felix!!!

## Further information

For this section, the book links are especially important.

- [Ownership](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)
- [Reference and borrowing](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_19" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Move Semantics 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// move_semantics1.rs
// Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let vec1 = fill_vec(vec0);

    println!(&quot;{} has length {} content `{:?}`&quot;, &quot;vec1&quot;, vec1.len(), vec1);

    vec1.push(88);

    println!(&quot;{} has length {} content `{:?}`&quot;, &quot;vec1&quot;, vec1.len(), vec1);
}

fn fill_vec(vec: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_20" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Move Semantics 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// move_semantics2.rs
// Make me compile without changing line 13 or moving line 10!
// Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.

// Expected output:
// vec0 has length 3 content `[22, 44, 66]`
// vec1 has length 4 content `[22, 44, 66, 88]`

// I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    // Do not change the following line!
    println!(&quot;{} has length {} content `{:?}`&quot;, &quot;vec0&quot;, vec0.len(), vec0);

    vec1.push(88);

    println!(&quot;{} has length {} content `{:?}`&quot;, &quot;vec1&quot;, vec1.len(), vec1);
}

fn fill_vec(vec: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_21" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Structs

Rust has three struct types: a classic C struct, a tuple struct, and a unit struct.

## Further information

- [Structures](https://doc.rust-lang.org/book/ch05-01-defining-structs.html)
- [Method Syntax](https://doc.rust-lang.org/book/ch05-03-method-syntax.html)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_22" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Structs 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// structs1.rs
// Address all the TODOs to make the tests pass!
// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

struct ColorClassicStruct {
    // TODO: Something goes here
}

struct ColorTupleStruct(/* TODO: Something goes here */);

#[derive(Debug)]
struct UnitLikeStruct;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn classic_c_structs() {
        // TODO: Instantiate a classic c struct!
        // let green =

        assert_eq!(green.red, 0);
        assert_eq!(green.green, 255);
        assert_eq!(green.blue, 0);
    }

    #[test]
    fn tuple_structs() {
        // TODO: Instantiate a tuple struct!
        // let green =

        assert_eq!(green.0, 0);
        assert_eq!(green.1, 255);
        assert_eq!(green.2, 0);
    }

    #[test]
    fn unit_structs() {
        // TODO: Instantiate a unit-like struct!
        // let unit_like_struct =
        let message = format!(&quot;{:?}s are fun!&quot;, unit_like_struct);

        assert_eq!(message, &quot;UnitLikeStructs are fun!&quot;);
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_23" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Structs 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// structs2.rs
// Address all the TODOs to make the tests pass!
// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[derive(Debug)]
struct Order {
    name: String,
    year: u32,
    made_by_phone: bool,
    made_by_mobile: bool,
    made_by_email: bool,
    item_number: u32,
    count: u32,
}

fn create_order_template() -&gt; Order {
    Order {
        name: String::from(&quot;Bob&quot;),
        year: 2019,
        made_by_phone: false,
        made_by_mobile: false,
        made_by_email: true,
        item_number: 123,
        count: 0,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn your_order() {
        let order_template = create_order_template();
        // TODO: Create your own order using the update syntax and template above!
        // let your_order =
        assert_eq!(your_order.name, &quot;Hacker in Rust&quot;);
        assert_eq!(your_order.year, order_template.year);
        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);
        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);
        assert_eq!(your_order.made_by_email, order_template.made_by_email);
        assert_eq!(your_order.item_number, order_template.item_number);
        assert_eq!(your_order.count, 1);
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_24" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Enums

Rust allows you to define types called &quot;enums&quot; which enumerate possible values.
Enums are a feature in many languages, but their capabilities differ in each language. Rust‚Äôs enums are most similar to algebraic data types in functional languages, such as F#, OCaml, and Haskell.
Useful in combination with enums is Rust&#39;s &quot;pattern matching&quot; facility, which makes it easy to run different code for different values of an enumeration.

## Further information

- [Enums](https://doc.rust-lang.org/book/ch06-00-enums.html)
- [Pattern syntax](https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_25" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Enums 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// enums1.rs
// No hints this time! ;)

// I AM NOT DONE

#[derive(Debug)]
enum Message {
    // TODO: define a few types of messages as used below
}

fn main() {
    println!(&quot;{:?}&quot;, Message::Quit);
    println!(&quot;{:?}&quot;, Message::Echo);
    println!(&quot;{:?}&quot;, Message::Move);
    println!(&quot;{:?}&quot;, Message::ChangeColor);
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_26" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Enums 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// enums2.rs
// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[derive(Debug)]
enum Message {
    // TODO: define the different variants used below
}

impl Message {
    fn call(&amp;self) {
        println!(&quot;{:?}&quot;, self);
    }
}

fn main() {
    let messages = [
        Message::Move { x: 10, y: 30 },
        Message::Echo(String::from(&quot;hello world&quot;)),
        Message::ChangeColor(200, 255, 255),
        Message::Quit,
    ];

    for message in &amp;messages {
        message.call();
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_27" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Strings

Rust has two string types, a string slice (`&amp;str`) and an owned string (`String`).
We&#39;re not going to dictate when you should use which one, but we&#39;ll show you how
to identify and create them, as well as use them.

## Further information

- [Strings](https://doc.rust-lang.org/book/ch08-02-strings.html)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_28" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Strings 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// strings1.rs
// Make me compile without changing the function signature!
// Execute `rustlings hint strings1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let answer = current_favorite_color();
    println!(&quot;My current favorite color is {}&quot;, answer);
}

fn current_favorite_color() -&gt; String {
    &quot;blue&quot;
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_29" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Strings 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// strings2.rs
// Make me compile without changing the function signature!
// Execute `rustlings hint strings2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let word = String::from(&quot;green&quot;); // Try not changing this line :)
    if is_a_color_word(word) {
        println!(&quot;That is a color word I know!&quot;);
    } else {
        println!(&quot;That is not a color word I know.&quot;);
    }
}

fn is_a_color_word(attempt: &amp;str) -&gt; bool {
    attempt == &quot;green&quot; || attempt == &quot;blue&quot; || attempt == &quot;red&quot;
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_30" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Modules

In this section we&#39;ll give you an introduction to Rust&#39;s module system.

## Further information

- [The Module System](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_31" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Modules 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// modules1.rs
// Execute `rustlings hint modules1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

mod sausage_factory {
    // Don&#39;t let anybody outside of this module see this!
    fn get_secret_recipe() -&gt; String {
        String::from(&quot;Ginger&quot;)
    }

    fn make_sausage() {
        get_secret_recipe();
        println!(&quot;sausage!&quot;);
    }
}

fn main() {
    sausage_factory::make_sausage();
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_32" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Modules 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// modules2.rs
// You can bring module paths into scopes and provide new names for them with the
// &#39;use&#39; and &#39;as&#39; keywords. Fix these &#39;use&#39; statements to make the code compile.
// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

mod delicious_snacks {
    // TODO: Fix these use statements
    use self::fruits::PEAR as ???
    use self::veggies::CUCUMBER as ???

    mod fruits {
        pub const PEAR: &amp;&#39;static str = &quot;Pear&quot;;
        pub const APPLE: &amp;&#39;static str = &quot;Apple&quot;;
    }

    mod veggies {
        pub const CUCUMBER: &amp;&#39;static str = &quot;Cucumber&quot;;
        pub const CARROT: &amp;&#39;static str = &quot;Carrot&quot;;
    }
}

fn main() {
    println!(
        &quot;favorite snacks: {} and {}&quot;,
        delicious_snacks::fruit,
        delicious_snacks::veggie
    );
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_33" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Hashmaps

A *hash map* allows you to associate a value with a particular key.
You may also know this by the names [*unordered map* in C++](https://en.cppreference.com/w/cpp/container/unordered_map),
[*dictionary* in Python](https://docs.python.org/3/tutorial/datastructures.html#dictionaries) or an *associative array* in other languages.

This is the other data structure that we&#39;ve been talking about before, when
talking about Vecs.

## Further information

- [Storing Keys with Associated Values in Hash Maps](https://doc.rust-lang.org/book/ch08-03-hash-maps.html)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_34" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Hashmaps 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// hashmaps1.rs
// A basket of fruits in the form of a hash map needs to be defined.
// The key represents the name of the fruit and the value represents
// how many of that particular fruit is in the basket. You have to put
// at least three different types of fruits (e.g apple, banana, mango)
// in the basket and the total count of all the fruits should be at
// least five.
//
// Make me compile and pass the tests!
//
// Execute `rustlings hint hashmaps1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::collections::HashMap;

fn fruit_basket() -&gt; HashMap&lt;String, u32&gt; {
    let mut basket = // TODO: declare your hash map here.

    // Two bananas are already given for you :)
    basket.insert(String::from(&quot;banana&quot;), 2);

    // TODO: Put more fruits in your basket here.

    basket
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn at_least_three_types_of_fruits() {
        let basket = fruit_basket();
        assert!(basket.len() &gt;= 3);
    }

    #[test]
    fn at_least_five_fruits() {
        let basket = fruit_basket();
        assert!(basket.values().sum::&lt;u32&gt;() &gt;= 5);
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_35" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Hashmaps 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// hashmaps2.rs
// We&#39;re collecting different fruits to bake a delicious fruit cake.
// For this, we have a basket, which we&#39;ll represent in the form of a hash
// map. The key represents the name of each fruit we collect and the value
// represents how many of that particular fruit we have collected.
// Three types of fruits - Apple (4), Mango (2) and Lychee (5) are already
// in the basket hash map.
// You must add fruit to the basket so that there is at least
// one of each kind and more than 11 in total - we have a lot of mouths to feed.
// You are not allowed to insert any more of these fruits!
//
// Make me pass the tests!
//
// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::collections::HashMap;

#[derive(Hash, PartialEq, Eq)]
enum Fruit {
    Apple,
    Banana,
    Mango,
    Lychee,
    Pineapple,
}

fn fruit_basket(basket: &amp;mut HashMap&lt;Fruit, u32&gt;) {
    let fruit_kinds = vec![
        Fruit::Apple,
        Fruit::Banana,
        Fruit::Mango,
        Fruit::Lychee,
        Fruit::Pineapple,
    ];

    for fruit in fruit_kinds {
        // TODO: Insert new fruits if they are not already present in the basket.
        // Note that you are not allowed to put any type of fruit that&#39;s already
        // present!
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // Don&#39;t modify this function!
    fn get_fruit_basket() -&gt; HashMap&lt;Fruit, u32&gt; {
        let mut basket = HashMap::&lt;Fruit, u32&gt;::new();
        basket.insert(Fruit::Apple, 4);
        basket.insert(Fruit::Mango, 2);
        basket.insert(Fruit::Lychee, 5);

        basket
    }

    #[test]
    fn test_given_fruits_are_not_modified() {
        let mut basket = get_fruit_basket();
        fruit_basket(&amp;mut basket);
        assert_eq!(*basket.get(&amp;Fruit::Apple).unwrap(), 4);
        assert_eq!(*basket.get(&amp;Fruit::Mango).unwrap(), 2);
        assert_eq!(*basket.get(&amp;Fruit::Lychee).unwrap(), 5);
    }

    #[test]
    fn at_least_five_types_of_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&amp;mut basket);
        let count_fruit_kinds = basket.len();
        assert!(count_fruit_kinds &gt;= 5);
    }

    #[test]
    fn greater_than_eleven_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&amp;mut basket);
        let count = basket.values().sum::&lt;u32&gt;();
        assert!(count &gt; 11);
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_36" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Options

Type Option represents an optional value: every Option is either Some and contains a value, or None, and does not.
Option types are very common in Rust code, as they have a number of uses:

- Initial values
- Return values for functions that are not defined over their entire input range (partial functions)
- Return value for otherwise reporting simple errors, where None is returned on error
- Optional struct fields
- Struct fields that can be loaned or &quot;taken&quot;
- Optional function arguments
- Nullable pointers
- Swapping things out of difficult situations

## Further Information

- [Option Enum Format](https://doc.rust-lang.org/stable/book/ch10-01-syntax.html#in-enum-definitions)
- [Option Module Documentation](https://doc.rust-lang.org/std/option/)
- [Option Enum Documentation](https://doc.rust-lang.org/std/option/enum.Option.html)
- [if let](https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html)
- [while let](https://doc.rust-lang.org/rust-by-example/flow_control/while_let.html)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_37" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Options 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// options1.rs
// Execute `rustlings hint options1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

// This function returns how much icecream there is left in the fridge.
// If it&#39;s before 10PM, there&#39;s 5 pieces left. At 10PM, someone eats them
// all, so there&#39;ll be no more left :(
fn maybe_icecream(time_of_day: u16) -&gt; Option&lt;u16&gt; {
    // We use the 24-hour system here, so 10PM is a value of 22 and 12AM is a value of 0
    // The Option output should gracefully handle cases where time_of_day &gt; 23.
    // TODO: Complete the function body - remember to return an Option!
    ???
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn check_icecream() {
        assert_eq!(maybe_icecream(9), Some(5));
        assert_eq!(maybe_icecream(10), Some(5));
        assert_eq!(maybe_icecream(23), Some(0));
        assert_eq!(maybe_icecream(22), Some(0));
        assert_eq!(maybe_icecream(25), None);
    }

    #[test]
    fn raw_value() {
        // TODO: Fix this test. How do you get at the value contained in the Option?
        let icecreams = maybe_icecream(12);
        assert_eq!(icecreams, 5);
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_38" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Options 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// options2.rs
// Execute `rustlings hint options2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[cfg(test)]
mod tests {
    #[test]
    fn simple_option() {
        let target = &quot;rustlings&quot;;
        let optional_target = Some(target);

        // TODO: Make this an if let statement whose value is &quot;Some&quot; type
        word = optional_target {
            assert_eq!(word, target);
        }
    }

    #[test]
    fn layered_option() {
        let mut range = 10;
        let mut optional_integers: Vec&lt;Option&lt;i8&gt;&gt; = Vec::new();
        for i in 0..(range + 1) {
            optional_integers.push(Some(i));
        }

        // TODO: make this a while let statement - remember that vector.pop also adds another layer of Option&lt;T&gt;
        // You can stack `Option&lt;T&gt;`&#39;s into while let and if let
        integer = optional_integers.pop() {
            assert_eq!(integer, range);
            range -= 1;
        }
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_39" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Error handling

Most errors aren‚Äôt serious enough to require the program to stop entirely.
Sometimes, when a function fails, it‚Äôs for a reason that you can easily interpret and respond to.
For example, if you try to open a file and that operation fails because the file doesn‚Äôt exist, you might want to create the file instead of terminating the process.

## Further information

- [Error Handling](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html)
- [Generics](https://doc.rust-lang.org/book/ch10-01-syntax.html)
- [Result](https://doc.rust-lang.org/rust-by-example/error/result.html)
- [Boxing errors](https://doc.rust-lang.org/rust-by-example/error/multiple_error_types/boxing_errors.html)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_40" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Error Handling 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// errors1.rs
// This function refuses to generate text to be printed on a nametag if
// you pass it an empty string. It&#39;d be nicer if it explained what the problem
// was, instead of just sometimes returning `None`. Thankfully, Rust has a similar
// construct to `Option` that can be used to express error conditions. Let&#39;s use it!
// Execute `rustlings hint errors1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

pub fn generate_nametag_text(name: String) -&gt; Option&lt;String&gt; {
    if name.is_empty() {
        // Empty names aren&#39;t allowed.
        None
    } else {
        Some(format!(&quot;Hi! My name is {}&quot;, name))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generates_nametag_text_for_a_nonempty_name() {
        assert_eq!(
            generate_nametag_text(&quot;Beyonc√©&quot;.into()),
            Ok(&quot;Hi! My name is Beyonc√©&quot;.into())
        );
    }

    #[test]
    fn explains_why_generating_nametag_text_fails() {
        assert_eq!(
            generate_nametag_text(&quot;&quot;.into()),
            // Don&#39;t change this line
            Err(&quot;`name` was empty; it must be nonempty.&quot;.into())
        );
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_41" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Error Handling 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// errors2.rs
// Say we&#39;re writing a game where you can buy items with tokens. All items cost
// 5 tokens, and whenever you purchase items there is a processing fee of 1
// token. A player of the game will type in how many items they want to buy,
// and the `total_cost` function will calculate the total cost of the tokens.
// Since the player typed in the quantity, though, we get it as a string-- and
// they might have typed anything, not just numbers!

// Right now, this function isn&#39;t handling the error case at all (and isn&#39;t
// handling the success case properly either). What we want to do is:
// if we call the `parse` function on a string that is not a number, that
// function will return a `ParseIntError`, and in that case, we want to
// immediately return that error from our function and not try to multiply
// and add.

// There are at least two ways to implement this that are both correct-- but
// one is a lot shorter!
// Execute `rustlings hint errors2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::num::ParseIntError;

pub fn total_cost(item_quantity: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let processing_fee = 1;
    let cost_per_item = 5;
    let qty = item_quantity.parse::&lt;i32&gt;();

    Ok(qty * cost_per_item + processing_fee)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn item_quantity_is_a_valid_number() {
        assert_eq!(total_cost(&quot;34&quot;), Ok(171));
    }

    #[test]
    fn item_quantity_is_an_invalid_number() {
        assert_eq!(
            total_cost(&quot;beep boop&quot;).unwrap_err().to_string(),
            &quot;invalid digit found in string&quot;
        );
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_42" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Generics

Generics is the topic of generalizing types and functionalities to broader cases.
This is extremely useful for reducing code duplication in many ways, but can call for rather involving syntax.
Namely, being generic requires taking great care to specify over which types a generic type is actually considered valid.
The simplest and most common use of generics is for type parameters.

## Further information

- [Generic Data Types](https://doc.rust-lang.org/stable/book/ch10-01-syntax.html)
- [Bounds](https://doc.rust-lang.org/rust-by-example/generics/bounds.html)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_43" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Generics 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// This shopping list program isn&#39;t compiling!
// Use your knowledge of generics to fix it.

// Execute `rustlings hint generics1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let mut shopping_list: Vec&lt;?&gt; = Vec::new();
    shopping_list.push(&quot;milk&quot;);
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_44" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Generics 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// This powerful wrapper provides the ability to store a positive integer value.
// Rewrite it using generics so that it supports wrapping ANY type.

// Execute `rustlings hint generics2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

struct Wrapper {
    value: u32,
}

impl Wrapper {
    pub fn new(value: u32) -&gt; Self {
        Wrapper { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn store_u32_in_wrapper() {
        assert_eq!(Wrapper::new(42).value, 42);
    }

    #[test]
    fn store_str_in_wrapper() {
        assert_eq!(Wrapper::new(&quot;Foo&quot;).value, &quot;Foo&quot;);
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_45" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Traits

A trait is a collection of methods.

Data types can implement traits. To do so, the methods making up the trait are defined for the data type. For example, the `String` data type implements the `From&lt;&amp;str&gt;` trait. This allows a user to write `String::from(&quot;hello&quot;)`.

In this way, traits are somewhat similar to Java interfaces and C++ abstract classes.

Some additional common Rust traits include:

- `Clone` (the `clone` method)
- `Display` (which allows formatted display via `{}`)
- `Debug` (which allows formatted display via `{:?}`)

Because traits indicate shared behavior between data types, they are useful when writing generics.

## Further information

- [Traits](https://doc.rust-lang.org/book/ch10-02-traits.html)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_46" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Traits 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// traits1.rs
// Time to implement some traits!
//
// Your task is to implement the trait
// `AppendBar` for the type `String`.
//
// The trait AppendBar has only one function,
// which appends &quot;Bar&quot; to any object
// implementing this trait.
// Execute `rustlings hint traits1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

trait AppendBar {
    fn append_bar(self) -&gt; Self;
}

impl AppendBar for String {
    // TODO: Implement `AppendBar` for type `String`.
}

fn main() {
    let s = String::from(&quot;Foo&quot;);
    let s = s.append_bar();
    println!(&quot;s: {}&quot;, s);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_foo_bar() {
        assert_eq!(String::from(&quot;Foo&quot;).append_bar(), String::from(&quot;FooBar&quot;));
    }

    #[test]
    fn is_bar_bar() {
        assert_eq!(
            String::from(&quot;&quot;).append_bar().append_bar(),
            String::from(&quot;BarBar&quot;)
        );
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_47" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Traits 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// traits2.rs
//
// Your task is to implement the trait
// `AppendBar` for a vector of strings.
//
// To implement this trait, consider for
// a moment what it means to &#39;append &quot;Bar&quot;&#39;
// to a vector of strings.
//
// No boiler plate code this time,
// you can do this!
// Execute `rustlings hint traits2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

trait AppendBar {
    fn append_bar(self) -&gt; Self;
}

// TODO: Implement trait `AppendBar` for a vector of strings.

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_vec_pop_eq_bar() {
        let mut foo = vec![String::from(&quot;Foo&quot;)].append_bar();
        assert_eq!(foo.pop().unwrap(), String::from(&quot;Bar&quot;));
        assert_eq!(foo.pop().unwrap(), String::from(&quot;Foo&quot;));
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_48" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Tests

Going out of order from the book to cover tests -- many of the following exercises will ask you to make tests pass!

## Further information

- [Writing Tests](https://doc.rust-lang.org/book/ch11-01-writing-tests.html)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_49" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Tests 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// tests1.rs
// Tests are important to ensure that your code does what you think it should do.
// Tests can be run on this file with the following command:
// rustlings run tests1

// This test has a problem with it -- make the test compile! Make the test
// pass! Make the test fail!
// Execute `rustlings hint tests1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[cfg(test)]
mod tests {
    #[test]
    fn you_can_assert() {
        assert!();
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_50" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Tests 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// tests2.rs
// This test has a problem with it -- make the test compile! Make the test
// pass! Make the test fail!
// Execute `rustlings hint tests2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[cfg(test)]
mod tests {
    #[test]
    fn you_can_assert_eq() {
        assert_eq!();
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_51" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Lifetimes

Lifetimes tell the compiler how to check whether references live long
enough to be valid in any given situation. For example lifetimes say
&quot;make sure parameter &#39;a&#39; lives as long as parameter &#39;b&#39; so that the return
value is valid&quot;.

They are only necessary on borrows, i.e. references,
since copied parameters or moves are owned in their scope and cannot
be referenced outside. Lifetimes mean that calling code of e.g. functions
can be checked to make sure their arguments are valid. Lifetimes are
restrictive of their callers.

If you&#39;d like to learn more about lifetime annotations, the
[lifetimekata](https://tfpk.github.io/lifetimekata/) project
has a similar style of exercises to Rustlings, but is all about
learning to write lifetime annotations.

## Further information

- [Lifetimes (in Rust By Example)](https://doc.rust-lang.org/stable/rust-by-example/scope/lifetime.html)
- [Validating References with Lifetimes](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_52" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Lifetimes 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// lifetimes1.rs
//
// The Rust compiler needs to know how to check whether supplied references are
// valid, so that it can let the programmer know if a reference is at risk
// of going out of scope before it is used. Remember, references are borrows
// and do not own their own data. What if their owner goes out of scope?
//
// Execute `rustlings hint lifetimes1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is &#39;{}&#39;&quot;, result);
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_53" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Lifetimes 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// lifetimes2.rs
//
// So if the compiler is just validating the references passed
// to the annotated parameters and the return type, what do
// we need to change?
//
// Execute `rustlings hint lifetimes2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is &#39;{}&#39;&quot;, result);
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_54" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Iterators

This section will teach you about Iterators.

## Further information

- [Iterator](https://doc.rust-lang.org/book/ch13-02-iterators.html)
- [Iterator documentation](https://doc.rust-lang.org/stable/std/iter/)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_55" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Iterators 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// iterators1.rs
//
//  Make me compile by filling in the `???`s
//
// When performing operations on elements within a collection, iterators are essential.
// This module helps you get familiar with the structure of using an iterator and
// how to go through elements within an iterable collection.
//
// Execute `rustlings hint iterators1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let my_fav_fruits = vec![&quot;banana&quot;, &quot;custard apple&quot;, &quot;avocado&quot;, &quot;peach&quot;, &quot;raspberry&quot;];

    let mut my_iterable_fav_fruits = ???;   // TODO: Step 1

    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;&quot;banana&quot;));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     // TODO: Step 2
    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;&quot;avocado&quot;));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     // TODO: Step 3
    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;&quot;raspberry&quot;));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     // TODO: Step 4
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_56" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Iterators 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// iterators2.rs
// In this exercise, you&#39;ll learn some of the unique advantages that iterators
// can offer. Follow the steps to complete the exercise.
// Execute `rustlings hint iterators2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

// Step 1.
// Complete the `capitalize_first` function.
// &quot;hello&quot; -&gt; &quot;Hello&quot;
pub fn capitalize_first(input: &amp;str) -&gt; String {
    let mut c = input.chars();
    match c.next() {
        None =&gt; String::new(),
        Some(first) =&gt; ???,
    }
}

// Step 2.
// Apply the `capitalize_first` function to a slice of string slices.
// Return a vector of strings.
// [&quot;hello&quot;, &quot;world&quot;] -&gt; [&quot;Hello&quot;, &quot;World&quot;]
pub fn capitalize_words_vector(words: &amp;[&amp;str]) -&gt; Vec&lt;String&gt; {
    vec![]
}

// Step 3.
// Apply the `capitalize_first` function again to a slice of string slices.
// Return a single string.
// [&quot;hello&quot;, &quot; &quot;, &quot;world&quot;] -&gt; &quot;Hello World&quot;
pub fn capitalize_words_string(words: &amp;[&amp;str]) -&gt; String {
    String::new()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_success() {
        assert_eq!(capitalize_first(&quot;hello&quot;), &quot;Hello&quot;);
    }

    #[test]
    fn test_empty() {
        assert_eq!(capitalize_first(&quot;&quot;), &quot;&quot;);
    }

    #[test]
    fn test_iterate_string_vec() {
        let words = vec![&quot;hello&quot;, &quot;world&quot;];
        assert_eq!(capitalize_words_vector(&amp;words), [&quot;Hello&quot;, &quot;World&quot;]);
    }

    #[test]
    fn test_iterate_into_string() {
        let words = vec![&quot;hello&quot;, &quot; &quot;, &quot;world&quot;];
        assert_eq!(capitalize_words_string(&amp;words), &quot;Hello World&quot;);
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_57" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Threads

In most current operating systems, an executed program‚Äôs code is run in a process, and the operating system manages multiple processes at once.
Within your program, you can also have independent parts that run simultaneously. The features that run these independent parts are called threads.

## Further information

- [Dining Philosophers example](https://doc.rust-lang.org/1.4.0/book/dining-philosophers.html)
- [Using Threads to Run Code Simultaneously](https://doc.rust-lang.org/book/ch16-01-threads.html)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_58" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Threads 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// threads1.rs
// Execute `rustlings hint threads1` or use the `hint` watch subcommand for a hint.

// This program spawns multiple threads that each run for at least 250ms,
// and each thread returns how much time they took to complete.
// The program should wait until all the spawned threads have finished and
// should collect their return values into a vector.

// I AM NOT DONE

use std::thread;
use std::time::{Duration, Instant};

fn main() {
    let mut handles = vec![];
    for i in 0..10 {
        handles.push(thread::spawn(move || {
            let start = Instant::now();
            thread::sleep(Duration::from_millis(250));
            println!(&quot;thread {} is complete&quot;, i);
            start.elapsed().as_millis()
        }));
    }

    let mut results: Vec&lt;u128&gt; = vec![];
    for handle in handles {
        // TODO: a struct is returned from thread::spawn, can you use it?
    }

    if results.len() != 10 {
        panic!(&quot;Oh no! All the spawned threads did not finish!&quot;);
    }

    println!();
    for (i, result) in results.into_iter().enumerate() {
        println!(&quot;thread {} took {}ms&quot;, i, result);
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_59" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Threads 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// threads2.rs
// Execute `rustlings hint threads2` or use the `hint` watch subcommand for a hint.
// Building on the last exercise, we want all of the threads to complete their work but this time
// the spawned threads need to be in charge of updating a shared value: JobStatus.jobs_completed

// I AM NOT DONE

use std::sync::Arc;
use std::thread;
use std::time::Duration;

struct JobStatus {
    jobs_completed: u32,
}

fn main() {
    let status = Arc::new(JobStatus { jobs_completed: 0 });
    let mut handles = vec![];
    for _ in 0..10 {
        let status_shared = Arc::clone(&amp;status);
        let handle = thread::spawn(move || {
            thread::sleep(Duration::from_millis(250));
            // TODO: You must take an action before you update a shared value
            status_shared.jobs_completed += 1;
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
        // TODO: Print the value of the JobStatus.jobs_completed. Did you notice anything
        // interesting in the output? Do you have to &#39;join&#39; on all the handles?
        println!(&quot;jobs completed {}&quot;, ???);
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_60" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Smart Pointers

In Rust, smart pointers are variables that contain an address in memory and reference some other data, but they also have additional metadata and capabilities.
Smart pointers in Rust often own the data they point to, while references only borrow data.

## Further Information

- [Smart Pointers](https://doc.rust-lang.org/book/ch15-00-smart-pointers.html)
- [Using Box to Point to Data on the Heap](https://doc.rust-lang.org/book/ch15-01-box.html)
- [Rc\&lt;T\&gt;, the Reference Counted Smart Pointer](https://doc.rust-lang.org/book/ch15-04-rc.html)
- [Shared-State Concurrency](https://doc.rust-lang.org/book/ch16-03-shared-state.html)
- [Cow Documentation](https://doc.rust-lang.org/std/borrow/enum.Cow.html)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_61" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Smart Pointers arc</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// arc1.rs
// In this exercise, we are given a Vec of u32 called &quot;numbers&quot; with values ranging
// from 0 to 99 -- [ 0, 1, 2, ..., 98, 99 ]
// We would like to use this set of numbers within 8 different threads simultaneously.
// Each thread is going to get the sum of every eighth value, with an offset.
// The first thread (offset 0), will sum 0, 8, 16, ...
// The second thread (offset 1), will sum 1, 9, 17, ...
// The third thread (offset 2), will sum 2, 10, 18, ...
// ...
// The eighth thread (offset 7), will sum 7, 15, 23, ...

// Because we are using threads, our values need to be thread-safe.  Therefore,
// we are using Arc.  We need to make a change in each of the two TODOs.


// Make this code compile by filling in a value for `shared_numbers` where the
// first TODO comment is, and create an initial binding for `child_numbers`
// where the second TODO comment is. Try not to create any copies of the `numbers` Vec!
// Execute `rustlings hint arc1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#![forbid(unused_imports)] // Do not change this, (or the next) line.
use std::sync::Arc;
use std::thread;

fn main() {
    let numbers: Vec&lt;_&gt; = (0..100u32).collect();
    let shared_numbers = // TODO
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let child_numbers = // TODO
        joinhandles.push(thread::spawn(move || {
            let sum: u32 = child_numbers.iter().filter(|&amp;&amp;n| n % 8 == offset).sum();
            println!(&quot;Sum of offset {} is {}&quot;, offset, sum);
        }));
    }
    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_62" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Smart Pointers box</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// box1.rs
//
// At compile time, Rust needs to know how much space a type takes up. This becomes problematic
// for recursive types, where a value can have as part of itself another value of the same type.
// To get around the issue, we can use a `Box` - a smart pointer used to store data on the heap,
// which also allows us to wrap a recursive type.
//
// The recursive type we&#39;re implementing in this exercise is the `cons list` - a data structure
// frequently found in functional programming languages. Each item in a cons list contains two
// elements: the value of the current item and the next item. The last item is a value called `Nil`.
//
// Step 1: use a `Box` in the enum definition to make the code compile
// Step 2: create both empty and non-empty cons lists by replacing `todo!()`
//
// Note: the tests should not be changed
//
// Execute `rustlings hint box1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[derive(PartialEq, Debug)]
pub enum List {
    Cons(i32, List),
    Nil,
}

fn main() {
    println!(&quot;This is an empty cons list: {:?}&quot;, create_empty_list());
    println!(
        &quot;This is a non-empty cons list: {:?}&quot;,
        create_non_empty_list()
    );
}

pub fn create_empty_list() -&gt; List {
    todo!()
}

pub fn create_non_empty_list() -&gt; List {
    todo!()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_empty_list() {
        assert_eq!(List::Nil, create_empty_list())
    }

    #[test]
    fn test_create_non_empty_list() {
        assert_ne!(create_empty_list(), create_non_empty_list())
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_63" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Smart Pointers cow</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// cow1.rs

// This exercise explores the Cow, or Clone-On-Write type.
// Cow is a clone-on-write smart pointer.
// It can enclose and provide immutable access to borrowed data, and clone the data lazily when mutation or ownership is required.
// The type is designed to work with general borrowed data via the Borrow trait.
//
// This exercise is meant to show you what to expect when passing data to Cow.
// Fix the unit tests by checking for Cow::Owned(_) and Cow::Borrowed(_) at the TODO markers.

// I AM NOT DONE

use std::borrow::Cow;

fn abs_all&lt;&#39;a, &#39;b&gt;(input: &amp;&#39;a mut Cow&lt;&#39;b, [i32]&gt;) -&gt; &amp;&#39;a mut Cow&lt;&#39;b, [i32]&gt; {
    for i in 0..input.len() {
        let v = input[i];
        if v &lt; 0 {
            // Clones into a vector if not already owned.
            input.to_mut()[i] = -v;
        }
    }
    input
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn reference_mutation() -&gt; Result&lt;(), &amp;&#39;static str&gt; {
        // Clone occurs because `input` needs to be mutated.
        let slice = [-1, 0, 1];
        let mut input = Cow::from(&amp;slice[..]);
        match abs_all(&amp;mut input) {
            Cow::Owned(_) =&gt; Ok(()),
            _ =&gt; Err(&quot;Expected owned value&quot;),
        }
    }

    #[test]
    fn reference_no_mutation() -&gt; Result&lt;(), &amp;&#39;static str&gt; {
        // No clone occurs because `input` doesn&#39;t need to be mutated.
        let slice = [0, 1, 2];
        let mut input = Cow::from(&amp;slice[..]);
        match abs_all(&amp;mut input) {
            // TODO
        }
    }

    #[test]
    fn owned_no_mutation() -&gt; Result&lt;(), &amp;&#39;static str&gt; {
        // We can also pass `slice` without `&amp;` so Cow owns it directly.
        // In this case no mutation occurs and thus also no clone,
        // but the result is still owned because it always was.
        let slice = vec![0, 1, 2];
        let mut input = Cow::from(slice);
        match abs_all(&amp;mut input) {
            // TODO
        }
    }

    #[test]
    fn owned_mutation() -&gt; Result&lt;(), &amp;&#39;static str&gt; {
        // Of course this is also the case if a mutation does occur.
        // In this case the call to `to_mut()` returns a reference to
        // the same data as before.
        let slice = vec![-1, 0, 1];
        let mut input = Cow::from(slice);
        match abs_all(&amp;mut input) {
            // TODO
        }
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_64" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Smart Pointers rc</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// rc1.rs
// In this exercise, we want to express the concept of multiple owners via the Rc&lt;T&gt; type.
// This is a model of our solar system - there is a Sun type and multiple Planets.
// The Planets take ownership of the sun, indicating that they revolve around the sun.

// Make this code compile by using the proper Rc primitives to express that the sun has multiple owners.

// I AM NOT DONE

use std::rc::Rc;

#[derive(Debug)]
struct Sun {}

#[derive(Debug)]
enum Planet {
    Mercury(Rc&lt;Sun&gt;),
    Venus(Rc&lt;Sun&gt;),
    Earth(Rc&lt;Sun&gt;),
    Mars(Rc&lt;Sun&gt;),
    Jupiter(Rc&lt;Sun&gt;),
    Saturn(Rc&lt;Sun&gt;),
    Uranus(Rc&lt;Sun&gt;),
    Neptune(Rc&lt;Sun&gt;),
}

impl Planet {
    fn details(&amp;self) {
        println!(&quot;Hi from {:?}!&quot;, self)
    }
}

fn main() {
    let sun = Rc::new(Sun {});
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 1 reference

    let mercury = Planet::Mercury(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 2 references
    mercury.details();

    let venus = Planet::Venus(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 3 references
    venus.details();

    let earth = Planet::Earth(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 4 references
    earth.details();

    let mars = Planet::Mars(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 5 references
    mars.details();

    let jupiter = Planet::Jupiter(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 6 references
    jupiter.details();

    // TODO
    let saturn = Planet::Saturn(Rc::new(Sun {}));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 7 references
    saturn.details();

    // TODO
    let uranus = Planet::Uranus(Rc::new(Sun {}));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 8 references
    uranus.details();

    // TODO
    let neptune = Planet::Neptune(Rc::new(Sun {}));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 9 references
    neptune.details();

    assert_eq!(Rc::strong_count(&amp;sun), 9);

    drop(neptune);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 8 references

    drop(uranus);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 7 references

    drop(saturn);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 6 references

    drop(jupiter);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 5 references

    drop(mars);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 4 references

    // TODO
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 3 references

    // TODO
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 2 references

    // TODO
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 1 reference

    assert_eq!(Rc::strong_count(&amp;sun), 1);
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_65" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Macros

Rust&#39;s macro system is very powerful, but also kind of difficult to wrap your
head around. We&#39;re not going to teach you how to write your own fully-featured
macros. Instead, we&#39;ll show you how to use and create them.

If you&#39;d like to learn more about writing your own macros, the
[macrokata](https://github.com/tfpk/macrokata) project has a similar style
of exercises to Rustlings, but is all about learning to write Macros.

## Further information

- [Macros](https://doc.rust-lang.org/book/ch19-06-macros.html)
- [The Little Book of Rust Macros](https://veykril.github.io/tlborm/)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_66" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Macros 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// macros1.rs
// Execute `rustlings hint macros1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

macro_rules! my_macro {
    () =&gt; {
        println!(&quot;Check out my macro!&quot;);
    };
}

fn main() {
    my_macro();
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_67" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Macros 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// macros2.rs
// Execute `rustlings hint macros2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    my_macro!();
}

macro_rules! my_macro {
    () =&gt; {
        println!(&quot;Check out my macro!&quot;);
    };
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_68" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Clippy

The Clippy tool is a collection of lints to analyze your code so you can catch common mistakes and improve your Rust code.

If you used the installation script for Rustlings, Clippy should be already installed.
If not you can install it manually via `rustup component add clippy`.

## Further information

- [GitHub Repository](https://github.com/rust-lang/rust-clippy).
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_69" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Clippy 1</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// clippy1.rs
// The Clippy tool is a collection of lints to analyze your code
// so you can catch common mistakes and improve your Rust code.
//
// For these exercises the code will fail to compile when there are clippy warnings
// check clippy&#39;s suggestions from the output to solve the exercise.
// Execute `rustlings hint clippy1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::f32;

fn main() {
    let pi = 3.14f32;
    let radius = 5.00f32;

    let area = pi * f32::powi(radius, 2);

    println!(
        &quot;The area of a circle with radius {:.2} is {:.5}!&quot;,
        radius, area
    )
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_70" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Clippy 2</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// clippy2.rs
// Execute `rustlings hint clippy2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let mut res = 42;
    let option = Some(12);
    for x in option {
        res += x;
    }
    println!(&quot;{}&quot;, res);
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_71" hidden>
      <div class="code">
        <pre><code class="language-markdown"># Type conversions

Rust offers a multitude of ways to convert a value of a given type into another type.

The simplest form of type conversion is a type cast expression. It is denoted with the binary operator `as`. For instance, `println!(&quot;{}&quot;, 1 + 1.0);` would not compile, since `1` is an integer while `1.0` is a float. However, `println!(&quot;{}&quot;, 1 as f32 + 1.0)` should compile. The exercise [`using_as`](using_as.rs) tries to cover this.

Rust also offers traits that facilitate type conversions upon implementation. These traits can be found under the [`convert`](https://doc.rust-lang.org/std/convert/index.html) module.
The traits are the following:

- `From` and `Into` covered in [`from_into`](from_into.rs)
- `TryFrom` and `TryInto` covered in [`try_from_into`](try_from_into.rs)
- `AsRef` and `AsMut` covered in [`as_ref_mut`](as_ref_mut.rs)

Furthermore, the `std::str` module offers a trait called [`FromStr`](https://doc.rust-lang.org/std/str/trait.FromStr.html) which helps with converting strings into target types via the `parse` method on strings. If properly implemented for a given type `Person`, then `let p: Person = &quot;Mark,20&quot;.parse().unwrap()` should both compile and run without panicking.

These should be the main ways ***within the standard library*** to convert data into your desired types.

## Further information

These are not directly covered in the book, but the standard library has a great documentation for it.

- [conversions](https://doc.rust-lang.org/std/convert/index.html)
- [`FromStr` trait](https://doc.rust-lang.org/std/str/trait.FromStr.html)
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_72" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Conversions as_ref_mut</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// AsRef and AsMut allow for cheap reference-to-reference conversions.
// Read more about them at https://doc.rust-lang.org/std/convert/trait.AsRef.html
// and https://doc.rust-lang.org/std/convert/trait.AsMut.html, respectively.
// Execute `rustlings hint as_ref_mut` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

// Obtain the number of bytes (not characters) in the given argument.
// TODO: Add the AsRef trait appropriately as a trait bound.
fn byte_counter&lt;T&gt;(arg: T) -&gt; usize {
    arg.as_ref().as_bytes().len()
}

// Obtain the number of characters (not bytes) in the given argument.
// TODO: Add the AsRef trait appropriately as a trait bound.
fn char_counter&lt;T&gt;(arg: T) -&gt; usize {
    arg.as_ref().chars().count()
}

// Squares a number using as_mut().
// TODO: Add the appropriate trait bound.
fn num_sq&lt;T&gt;(arg: &amp;mut T) {
    // TODO: Implement the function body.
    ???
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn different_counts() {
        let s = &quot;Caf√© au lait&quot;;
        assert_ne!(char_counter(s), byte_counter(s));
    }

    #[test]
    fn same_counts() {
        let s = &quot;Cafe au lait&quot;;
        assert_eq!(char_counter(s), byte_counter(s));
    }

    #[test]
    fn different_counts_using_string() {
        let s = String::from(&quot;Caf√© au lait&quot;);
        assert_ne!(char_counter(s.clone()), byte_counter(s));
    }

    #[test]
    fn same_counts_using_string() {
        let s = String::from(&quot;Cafe au lait&quot;);
        assert_eq!(char_counter(s.clone()), byte_counter(s));
    }

    #[test]
    fn mult_box() {
        let mut num: Box&lt;u32&gt; = Box::new(3);
        num_sq(&amp;mut num);
        assert_eq!(*num, 9);
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_73" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Conversions from_into</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// The From trait is used for value-to-value conversions.
// If From is implemented correctly for a type, the Into trait should work conversely.
// You can read more about it at https://doc.rust-lang.org/std/convert/trait.From.html
// Execute `rustlings hint from_into` or use the `hint` watch subcommand for a hint.

#[derive(Debug)]
struct Person {
    name: String,
    age: usize,
}

// We implement the Default trait to use it as a fallback
// when the provided string is not convertible into a Person object
impl Default for Person {
    fn default() -&gt; Person {
        Person {
            name: String::from(&quot;John&quot;),
            age: 30,
        }
    }
}

// Your task is to complete this implementation
// in order for the line `let p = Person::from(&quot;Mark,20&quot;)` to compile
// Please note that you&#39;ll need to parse the age component into a `usize`
// with something like `&quot;4&quot;.parse::&lt;usize&gt;()`. The outcome of this needs to
// be handled appropriately.
//
// Steps:
// 1. If the length of the provided string is 0, then return the default of Person
// 2. Split the given string on the commas present in it
// 3. Extract the first element from the split operation and use it as the name
// 4. If the name is empty, then return the default of Person
// 5. Extract the other element from the split operation and parse it into a `usize` as the age
// If while parsing the age, something goes wrong, then return the default of Person
// Otherwise, then return an instantiated Person object with the results

// I AM NOT DONE

impl From&lt;&amp;str&gt; for Person {
    fn from(s: &amp;str) -&gt; Person {
    }
}

fn main() {
    // Use the `from` function
    let p1 = Person::from(&quot;Mark,20&quot;);
    // Since From is implemented for Person, we should be able to use Into
    let p2: Person = &quot;Gerald,70&quot;.into();
    println!(&quot;{:?}&quot;, p1);
    println!(&quot;{:?}&quot;, p2);
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_default() {
        // Test that the default person is 30 year old John
        let dp = Person::default();
        assert_eq!(dp.name, &quot;John&quot;);
        assert_eq!(dp.age, 30);
    }
    #[test]
    fn test_bad_convert() {
        // Test that John is returned when bad string is provided
        let p = Person::from(&quot;&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }
    #[test]
    fn test_good_convert() {
        // Test that &quot;Mark,20&quot; works
        let p = Person::from(&quot;Mark,20&quot;);
        assert_eq!(p.name, &quot;Mark&quot;);
        assert_eq!(p.age, 20);
    }
    #[test]
    fn test_bad_age() {
        // Test that &quot;Mark,twenty&quot; will return the default person due to an error in parsing age
        let p = Person::from(&quot;Mark,twenty&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_comma_and_age() {
        let p: Person = Person::from(&quot;Mark&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_age() {
        let p: Person = Person::from(&quot;Mark,&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name() {
        let p: Person = Person::from(&quot;,1&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name_and_age() {
        let p: Person = Person::from(&quot;,&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name_and_invalid_age() {
        let p: Person = Person::from(&quot;,one&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_trailing_comma() {
        let p: Person = Person::from(&quot;Mike,32,&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_trailing_comma_and_some_string() {
        let p: Person = Person::from(&quot;Mike,32,man&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_74" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Conversions from_str</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// from_str.rs
// This is similar to from_into.rs, but this time we&#39;ll implement `FromStr`
// and return errors instead of falling back to a default value.
// Additionally, upon implementing FromStr, you can use the `parse` method
// on strings to generate an object of the implementor type.
// You can read more about it at https://doc.rust-lang.org/std/str/trait.FromStr.html
// Execute `rustlings hint from_str` or use the `hint` watch subcommand for a hint.

use std::num::ParseIntError;
use std::str::FromStr;

#[derive(Debug, PartialEq)]
struct Person {
    name: String,
    age: usize,
}

// We will use this error type for the `FromStr` implementation.
#[derive(Debug, PartialEq)]
enum ParsePersonError {
    // Empty input string
    Empty,
    // Incorrect number of fields
    BadLen,
    // Empty name field
    NoName,
    // Wrapped error from parse::&lt;usize&gt;()
    ParseInt(ParseIntError),
}

// I AM NOT DONE

// Steps:
// 1. If the length of the provided string is 0, an error should be returned
// 2. Split the given string on the commas present in it
// 3. Only 2 elements should be returned from the split, otherwise return an error
// 4. Extract the first element from the split operation and use it as the name
// 5. Extract the other element from the split operation and parse it into a `usize` as the age
//    with something like `&quot;4&quot;.parse::&lt;usize&gt;()`
// 6. If while extracting the name and the age something goes wrong, an error should be returned
// If everything goes well, then return a Result of a Person object
//
// As an aside: `Box&lt;dyn Error&gt;` implements `From&lt;&amp;&#39;_ str&gt;`. This means that if you want to return a
// string error message, you can do so via just using return `Err(&quot;my error message&quot;.into())`.

impl FromStr for Person {
    type Err = ParsePersonError;
    fn from_str(s: &amp;str) -&gt; Result&lt;Person, Self::Err&gt; {
    }
}

fn main() {
    let p = &quot;Mark,20&quot;.parse::&lt;Person&gt;().unwrap();
    println!(&quot;{:?}&quot;, p);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn empty_input() {
        assert_eq!(&quot;&quot;.parse::&lt;Person&gt;(), Err(ParsePersonError::Empty));
    }
    #[test]
    fn good_input() {
        let p = &quot;John,32&quot;.parse::&lt;Person&gt;();
        assert!(p.is_ok());
        let p = p.unwrap();
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 32);
    }
    #[test]
    fn missing_age() {
        assert!(matches!(
            &quot;John,&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn invalid_age() {
        assert!(matches!(
            &quot;John,twenty&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn missing_comma_and_age() {
        assert_eq!(&quot;John&quot;.parse::&lt;Person&gt;(), Err(ParsePersonError::BadLen));
    }

    #[test]
    fn missing_name() {
        assert_eq!(&quot;,1&quot;.parse::&lt;Person&gt;(), Err(ParsePersonError::NoName));
    }

    #[test]
    fn missing_name_and_age() {
        assert!(matches!(
            &quot;,&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn missing_name_and_invalid_age() {
        assert!(matches!(
            &quot;,one&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn trailing_comma() {
        assert_eq!(&quot;John,32,&quot;.parse::&lt;Person&gt;(), Err(ParsePersonError::BadLen));
    }

    #[test]
    fn trailing_comma_and_some_string() {
        assert_eq!(
            &quot;John,32,man&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::BadLen)
        );
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_75" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Conversions try_from_into</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// try_from_into.rs
// TryFrom is a simple and safe type conversion that may fail in a controlled way under some circumstances.
// Basically, this is the same as From. The main difference is that this should return a Result type
// instead of the target type itself.
// You can read more about it at https://doc.rust-lang.org/std/convert/trait.TryFrom.html
// Execute `rustlings hint try_from_into` or use the `hint` watch subcommand for a hint.

use std::convert::{TryFrom, TryInto};

#[derive(Debug, PartialEq)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

// We will use this error type for these `TryFrom` conversions.
#[derive(Debug, PartialEq)]
enum IntoColorError {
    // Incorrect length of slice
    BadLen,
    // Integer conversion error
    IntConversion,
}

// I AM NOT DONE

// Your task is to complete this implementation
// and return an Ok result of inner type Color.
// You need to create an implementation for a tuple of three integers,
// an array of three integers, and a slice of integers.
//
// Note that the implementation for tuple and array will be checked at compile time,
// but the slice implementation needs to check the slice length!
// Also note that correct RGB color values must be integers in the 0..=255 range.

// Tuple implementation
impl TryFrom&lt;(i16, i16, i16)&gt; for Color {
    type Error = IntoColorError;
    fn try_from(tuple: (i16, i16, i16)) -&gt; Result&lt;Self, Self::Error&gt; {
    }
}

// Array implementation
impl TryFrom&lt;[i16; 3]&gt; for Color {
    type Error = IntoColorError;
    fn try_from(arr: [i16; 3]) -&gt; Result&lt;Self, Self::Error&gt; {
    }
}

// Slice implementation
impl TryFrom&lt;&amp;[i16]&gt; for Color {
    type Error = IntoColorError;
    fn try_from(slice: &amp;[i16]) -&gt; Result&lt;Self, Self::Error&gt; {
    }
}

fn main() {
    // Use the `try_from` function
    let c1 = Color::try_from((183, 65, 14));
    println!(&quot;{:?}&quot;, c1);

    // Since TryFrom is implemented for Color, we should be able to use TryInto
    let c2: Result&lt;Color, _&gt; = [183, 65, 14].try_into();
    println!(&quot;{:?}&quot;, c2);

    let v = vec![183, 65, 14];
    // With slice we should use `try_from` function
    let c3 = Color::try_from(&amp;v[..]);
    println!(&quot;{:?}&quot;, c3);
    // or take slice within round brackets and use TryInto
    let c4: Result&lt;Color, _&gt; = (&amp;v[..]).try_into();
    println!(&quot;{:?}&quot;, c4);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tuple_out_of_range_positive() {
        assert_eq!(
            Color::try_from((256, 1000, 10000)),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_tuple_out_of_range_negative() {
        assert_eq!(
            Color::try_from((-1, -10, -256)),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_tuple_sum() {
        assert_eq!(
            Color::try_from((-1, 255, 255)),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_tuple_correct() {
        let c: Result&lt;Color, _&gt; = (183, 65, 14).try_into();
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    #[test]
    fn test_array_out_of_range_positive() {
        let c: Result&lt;Color, _&gt; = [1000, 10000, 256].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    #[test]
    fn test_array_out_of_range_negative() {
        let c: Result&lt;Color, _&gt; = [-10, -256, -1].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    #[test]
    fn test_array_sum() {
        let c: Result&lt;Color, _&gt; = [-1, 255, 255].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    #[test]
    fn test_array_correct() {
        let c: Result&lt;Color, _&gt; = [183, 65, 14].try_into();
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    #[test]
    fn test_slice_out_of_range_positive() {
        let arr = [10000, 256, 1000];
        assert_eq!(
            Color::try_from(&amp;arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_slice_out_of_range_negative() {
        let arr = [-256, -1, -10];
        assert_eq!(
            Color::try_from(&amp;arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_slice_sum() {
        let arr = [-1, 255, 255];
        assert_eq!(
            Color::try_from(&amp;arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_slice_correct() {
        let v = vec![183, 65, 14];
        let c: Result&lt;Color, _&gt; = Color::try_from(&amp;v[..]);
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    #[test]
    fn test_slice_excess_length() {
        let v = vec![0, 0, 0, 0];
        assert_eq!(Color::try_from(&amp;v[..]), Err(IntoColorError::BadLen));
    }
    #[test]
    fn test_slice_insufficient_length() {
        let v = vec![0, 0];
        assert_eq!(Color::try_from(&amp;v[..]), Err(IntoColorError::BadLen));
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_76" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Conversions using_as</code></pre>
      </div>
      <div class="code">
        <pre><code class="language-rust">// Type casting in Rust is done via the usage of the `as` operator.
// Please note that the `as` operator is not only used when type casting.
// It also helps with renaming imports.
//
// The goal is to make sure that the division does not fail to compile
// and returns the proper type.
// Execute `rustlings hint using_as` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn average(values: &amp;[f64]) -&gt; f64 {
    let total = values.iter().sum::&lt;f64&gt;();
    total / values.len()
}

fn main() {
    let values = [3.5, 0.3, 13.0, 11.7];
    println!(&quot;{}&quot;, average(&amp;values));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn returns_proper_type_and_value() {
        assert_eq!(average(&amp;[3.5, 0.3, 13.0, 11.7]), 7.125);
    }
}
</code><br></pre>
      </div>
    </div>
    <div class="slide" id="_77" hidden>
      <div class="title bordered">
        <pre><code class="language-plaintext hljs">Thanks to all contributors of rustlings!</code></pre>
      </div>
    </div>
  </div>
  <script type="module">
document.addEventListener('DOMContentLoaded', () => {
  hljs.highlightAll();
  for (const slide of document.getElementsByClassName('slide')) {
    slide.hidden = false;
  }
}, { once: true });

hljs.registerLanguage('armasm', armasm);
hljs.registerLanguage('c', c);
hljs.registerLanguage('clojure', clojure);
hljs.registerLanguage('cmake', cmake);
hljs.registerLanguage('coffeescript', coffeescript);
hljs.registerLanguage('cpp', cpp);
hljs.registerLanguage('csharp', csharp);
hljs.registerLanguage('css', css);
hljs.registerLanguage('dart', dart);
hljs.registerLanguage('diff', diff);
hljs.registerLanguage('elixir', elixir);
hljs.registerLanguage('erlang', erlang);
hljs.registerLanguage('go', go);
hljs.registerLanguage('graphql', graphql);
hljs.registerLanguage('groovy', groovy);
hljs.registerLanguage('haskell', haskell);
hljs.registerLanguage('ini', ini);
hljs.registerLanguage('java', java);
hljs.registerLanguage('javascript', javascript);
hljs.registerLanguage('json', json);
hljs.registerLanguage('julia', julia);
hljs.registerLanguage('kotlin', kotlin);
hljs.registerLanguage('less', less);
hljs.registerLanguage('lisp', lisp);
hljs.registerLanguage('lua', lua);
hljs.registerLanguage('makefile', makefile);
hljs.registerLanguage('markdown', markdown);
hljs.registerLanguage('objectivec', objectivec);
hljs.registerLanguage('perl', perl);
hljs.registerLanguage('php', php);
hljs.registerLanguage('plaintext', plaintext);
hljs.registerLanguage('python', python);
hljs.registerLanguage('r', r);
hljs.registerLanguage('ruby', ruby);
hljs.registerLanguage('rust', rust);
hljs.registerLanguage('scala', scala);
hljs.registerLanguage('scss', scss);
hljs.registerLanguage('shell', shell);
hljs.registerLanguage('sql', sql);
hljs.registerLanguage('swift', swift);
hljs.registerLanguage('typescript', typescript);
hljs.registerLanguage('vbnet', vbnet);
hljs.registerLanguage('xml', xml);
hljs.registerLanguage('yaml', yaml);

/* Import dependencies from CDN */
import hljs from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/core.min.js';
import armasm from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/armasm.min.js';
import c from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/c.min.js';
import clojure from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/clojure.min.js';
import cmake from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/cmake.min.js';
import coffeescript from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/coffeescript.min.js';
import cpp from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/cpp.min.js';
import csharp from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/csharp.min.js';
import css from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/css.min.js';
import dart from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/dart.min.js';
import diff from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/diff.min.js';
import elixir from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/elixir.min.js';
import erlang from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/erlang.min.js';
import go from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/go.min.js';
import graphql from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/graphql.min.js';
import groovy from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/groovy.min.js';
import haskell from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/haskell.min.js';
import ini from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/ini.min.js';
import java from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/java.min.js';
import javascript from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/javascript.min.js';
import json from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/json.min.js';
import julia from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/julia.min.js';
import kotlin from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/kotlin.min.js';
import less from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/less.min.js';
import lisp from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/lisp.min.js';
import lua from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/lua.min.js';
import makefile from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/makefile.min.js';
import markdown from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/markdown.min.js';
import objectivec from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/objectivec.min.js';
import perl from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/perl.min.js';
import php from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/php.min.js';
import plaintext from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/plaintext.min.js';
import python from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/python.min.js';
import r from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/r.min.js';
import ruby from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/ruby.min.js';
import rust from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/rust.min.js';
import scala from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/scala.min.js';
import scss from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/scss.min.js';
import shell from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/shell.min.js';
import sql from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/sql.min.js';
import swift from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/swift.min.js';
import typescript from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/typescript.min.js';
import vbnet from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/vbnet.min.js';
import xml from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/xml.min.js';
import yaml from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/es/languages/yaml.min.js';
  </script>
</body>
</html>
