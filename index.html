<!DOCTYPE HTML>
<html class="hljs">
<head>
<meta charset="utf-8">
<meta
  name="description"
  content="CodeSlide makes a slideshow for code snippets">
<meta
  name="viewport"
  content="width=device-width, initial-scale=1">
<style>
pre code.hljs {
  display: block;
  overflow-x: auto;
  padding: 1em;
}
code.hljs {
  padding: 3px 5px;
}
/*!
Retrieved from https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark-dimmed.min.css

Theme: GitHub Dark Dimmed
Description: Dark dimmed theme as seen on github.com
Author: github.com
Maintainer: @Hirse
Updated: 2021-05-15

Colors taken from GitHub's CSS
*/
.hljs {
  color: #adbac7;
  background: #22272e;
}
.hljs-doctag,
.hljs-keyword,
.hljs-meta .hljs-keyword,
.hljs-template-tag,
.hljs-template-variable,
.hljs-type,
.hljs-variable.language_ {
  color: #f47067;
}
.hljs-title,
.hljs-title.class_,
.hljs-title.class_.inherited__,
.hljs-title.function_ {
  color: #dcbdfb;
}
.hljs-attr,
.hljs-attribute,
.hljs-literal,
.hljs-meta,
.hljs-number,
.hljs-operator,
.hljs-selector-attr,
.hljs-selector-class,
.hljs-selector-id,
.hljs-variable {
  color: #6cb6ff;
}
.hljs-meta .hljs-string,
.hljs-regexp,
.hljs-string {
  color: #96d0ff;
}
.hljs-built_in,
.hljs-symbol {
  color: #f69d50;
}
.hljs-code,
.hljs-comment,
.hljs-formula {
  color: #768390;
}
.hljs-name,
.hljs-quote,
.hljs-selector-pseudo,
.hljs-selector-tag {
  color: #8ddb8c;
}
.hljs-subst {
  color: #adbac7;
}
.hljs-section {
  color: #316dca;
  font-weight: 700;
}
.hljs-bullet {
  color: #eac55f;
}
.hljs-emphasis {
  color: #adbac7;
  font-style: italic;
}
.hljs-strong {
  color: #adbac7;
  font-weight: 700;
}
.hljs-addition {
  color: #b4f1b4;
  background-color: #1b4721;
}
.hljs-deletion {
  color: #ffd8d3;
  background-color: #78191b;
}

/*! CodeSlide slides.horizontal.css */
html, body {
  margin: 0;
  -webkit-print-color-adjust: exact;
  print-color-adjust: exact;
  overflow: hidden;
}
a {
  color: dodgerblue;
}
li {
  margin-top: 0.25em;
}
p:empty {
  display: none;
}
pre {
  white-space: pre-wrap;
  overflow-wrap: break-word;
}
pre > code {
  display: block;
  padding: 1em;
}
.slide {
  min-width: calc(100vw - 4em);
  height: calc(100vh - 2em);
  padding: 1em 2em;
  overflow-y: scroll;
  scroll-snap-align: start;
  scroll-snap-stop: always;
  scrollbar-width: none;
}
.slide::-webkit-scrollbar {
  display: none;
}
@media only screen and (max-width: 768px) {
  .slide {
    height: calc(90% - 2em);
    height: calc(100svh - 2em);
  }
}
#slides {
  display: flex;
  flex-direction: row;
  width: 100vw;
  height: 100vh;
  overflow-x: scroll;
  overscroll-behavior: none;
  scroll-behavior: smooth;
  scroll-snap-type: x mandatory;
}
@media print {
  @page {
    margin: 0;
    size: auto;
  }
  #slides {
    width: auto;
    height: auto;
  }
}

@font-face {
  font-family: 'Source Code Pro';
  font-style: normal;
  font-weight: 300;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/sourcecodepro/v22/HI_diYsKILxRpg3hIP6sJ7fM7PqPMcMnZFqUwX28DJKQhM4.ttf) format('truetype');
}
@font-face {
  font-family: 'Source Code Pro';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/sourcecodepro/v22/HI_diYsKILxRpg3hIP6sJ7fM7PqPMcMnZFqUwX28DMyQhM4.ttf) format('truetype');
}
@font-face {
  font-family: 'Source Code Pro';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/sourcecodepro/v22/HI_diYsKILxRpg3hIP6sJ7fM7PqPMcMnZFqUwX28DCuXhM4.ttf) format('truetype');
}

/* Tomorrow Night Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */

/* Tomorrow Comment */
.hljs-comment {
  color: #969896;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-attribute,
.hljs-tag,
.hljs-regexp,
.ruby .hljs-constant,
.xml .hljs-tag .hljs-title,
.xml .hljs-pi,
.xml .hljs-doctype,
.html .hljs-doctype,
.css .hljs-id,
.css .hljs-class,
.css .hljs-pseudo {
  color: #cc6666;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-preprocessor,
.hljs-pragma,
.hljs-built_in,
.hljs-literal,
.hljs-params,
.hljs-constant {
  color: #de935f;
}

/* Tomorrow Yellow */
.ruby .hljs-class .hljs-title,
.css .hljs-rule .hljs-attribute {
  color: #f0c674;
}

/* Tomorrow Green */
.hljs-string,
.hljs-value,
.hljs-inheritance,
.hljs-header,
.hljs-name,
.ruby .hljs-symbol,
.xml .hljs-cdata {
  color: #b5bd68;
}

/* Tomorrow Aqua */
.hljs-title,
.css .hljs-hexcolor {
  color: #8abeb7;
}

/* Tomorrow Blue */
.hljs-function,
.python .hljs-decorator,
.python .hljs-title,
.ruby .hljs-function .hljs-title,
.ruby .hljs-title .hljs-keyword,
.perl .hljs-sub,
.javascript .hljs-title,
.coffeescript .hljs-title {
  color: #81a2be;
}

/* Tomorrow Purple */
.hljs-keyword,
.javascript .hljs-function {
  color: #b294bb;
}

.hljs {
  display: block;
  overflow-x: auto;
  background: #1d1f21;
  color: #c5c8c6;
}

.coffeescript .javascript,
.javascript .xml,
.tex .hljs-formula,
.xml .javascript,
.xml .vbscript,
.xml .css,
.xml .hljs-cdata {
  opacity: 0.5;
}

.hljs-addition {
  color: #718c00;
}

.hljs-deletion {
  color: #c82829;
}

code {
  font-family: Source Code Pro, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
  font-size: 85%;
}
#slides {
  font-family: system-ui;
  font-size: large;
  font-weight: normal;
  line-height: 1.5;
}
</style>
</head>
<body class="hljs">
<div id="slides">
<div class="slide" id="slide_0">
<h1 id="rustlings-as-an-example-of-codeslide-cli"><a href="https://github.com/rust-lang/rustlings">Rustlings</a> as an example of CodeSlide CLI</h1>
</div>
<div class="slide" id="slide_1">
<p><h1 id="rustlings-ü¶Ä‚ù§Ô∏è">rustlings ü¶Ä‚ù§Ô∏è</h1>
<p>Greetings and welcome to <code>rustlings</code>. This project contains small exercises to get you used to reading and writing Rust code. This includes reading and responding to compiler messages!</p>
<p><em>...looking for the old, web-based version of Rustlings? Try <a href="https://github.com/rust-lang/rustlings/tree/rustlings-1">here</a></em></p>
<p>Alternatively, for a first-time Rust learner, there are several other resources:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/index.html">The Book</a> - The most comprehensive resource for learning Rust, but a bit theoretical sometimes. You will be using this along with Rustlings!</li>
<li><a href="https://doc.rust-lang.org/rust-by-example/index.html">Rust By Example</a> - Learn Rust by solving little exercises! It&#39;s almost like <code>rustlings</code>, but online</li>
</ul>
<h2 id="getting-started">Getting Started</h2>
<p><em>Note: If you&#39;re on MacOS, make sure you&#39;ve installed Xcode and its developer tools by typing <code>xcode-select --install</code>.</em>
<em>Note: If you&#39;re on Linux, make sure you&#39;ve installed gcc. Deb: <code>sudo apt install gcc</code>. Yum: <code>sudo yum -y install gcc</code>.</em></p>
<p>You will need to have Rust installed. You can get it by visiting <a href="https://rustup.rs">https://rustup.rs</a>. This&#39;ll also install Cargo, Rust&#39;s package/project manager.</p>
<h2 id="macoslinux">MacOS/Linux</h2>
<p>Just run:</p>
<pre><code class="language-bash">curl -L https://raw.githubusercontent.com/rust-lang/rustlings/main/install.sh | bash
</code></pre>
<p>Or if you want it to be installed to a different path:</p>
<pre><code class="language-bash">curl -L https://raw.githubusercontent.com/rust-lang/rustlings/main/install.sh | bash -s mypath/
</code></pre>
<p>This will install Rustlings and give you access to the <code>rustlings</code> command. Run it to get started!</p>
<h3 id="nix">Nix</h3>
<p>Basically: Clone the repository at the latest tag, finally run <code>nix develop</code> or <code>nix-shell</code>.</p>
<pre><code class="language-bash"><span class="hljs-comment"># find out the latest version at https://github.com/rust-lang/rustlings/releases/latest (on edit 5.4.1)</span>
git <span class="hljs-built_in">clone</span> -b 5.4.1 --depth 1 https://github.com/rust-lang/rustlings
<span class="hljs-built_in">cd</span> rustlings
<span class="hljs-comment"># if nix version &gt; 2.3</span>
nix develop
<span class="hljs-comment"># if nix version &lt;= 2.3</span>
nix-shell
</code></pre>
<h2 id="windows">Windows</h2>
<p>In PowerShell (Run as Administrator), set <code>ExecutionPolicy</code> to <code>RemoteSigned</code>:</p>
<pre><code class="language-ps1"><span class="hljs-built_in">Set-ExecutionPolicy</span> <span class="hljs-literal">-ExecutionPolicy</span> RemoteSigned <span class="hljs-literal">-Scope</span> CurrentUser
</code></pre>
<p>Then, you can run:</p>
<pre><code class="language-ps1"><span class="hljs-built_in">Start-BitsTransfer</span> <span class="hljs-literal">-Source</span> https://raw.githubusercontent.com/rust<span class="hljs-literal">-lang</span>/rustlings/main/install.ps1 <span class="hljs-literal">-Destination</span> <span class="hljs-variable">$env:TMP</span>/install_rustlings.ps1; <span class="hljs-built_in">Unblock-File</span> <span class="hljs-variable">$env:TMP</span>/install_rustlings.ps1; <span class="hljs-built_in">Invoke-Expression</span> <span class="hljs-variable">$env:TMP</span>/install_rustlings.ps1
</code></pre>
<p>To install Rustlings. Same as on MacOS/Linux, you will have access to the <code>rustlings</code> command after it. Keep in mind that this works best in PowerShell, and any other terminals may give you errors.</p>
<p>If you get a permission denied message, you might have to exclude the directory where you cloned Rustlings in your antivirus.</p>
<h2 id="browser">Browser</h2>
<p><a href="https://gitpod.io/#https://github.com/rust-lang/rustlings"><img src="https://gitpod.io/button/open-in-gitpod.svg" alt="Open in Gitpod"></a></p>
<p><a href="https://github.com/codespaces/new/?repo=rust-lang%2Frustlings&ref=main"><img src="https://github.com/codespaces/badge.svg" alt="Open Rustlings On Codespaces"></a></p>
<h2 id="manually">Manually</h2>
<p>Basically: Clone the repository at the latest tag, run <code>cargo install --path .</code>.</p>
<pre><code class="language-bash"><span class="hljs-comment"># find out the latest version at https://github.com/rust-lang/rustlings/releases/latest (on edit 5.4.1)</span>
git <span class="hljs-built_in">clone</span> -b 5.4.1 --depth 1 https://github.com/rust-lang/rustlings
<span class="hljs-built_in">cd</span> rustlings
cargo install --force --path .
</code></pre>
<p>If there are installation errors, ensure that your toolchain is up to date. For the latest, run:</p>
<pre><code class="language-bash">rustup update
</code></pre>
<p>Then, same as above, run <code>rustlings</code> to get started.</p>
<h2 id="doing-exercises">Doing exercises</h2>
<p>The exercises are sorted by topic and can be found in the subdirectory <code>rustlings/exercises/&lt;topic&gt;</code>. For every topic there is an additional README file with some resources to get you started on the topic. We really recommend that you have a look at them before you start.</p>
<p>The task is simple. Most exercises contain an error that keeps them from compiling, and it&#39;s up to you to fix it! Some exercises are also run as tests, but rustlings handles them all the same. To run the exercises in the recommended order, execute:</p>
<pre><code class="language-bash">rustlings watch
</code></pre>
<p>This will try to verify the completion of every exercise in a predetermined order (what we think is best for newcomers). It will also rerun automatically every time you change a file in the <code>exercises/</code> directory. If you want to only run it once, you can use:</p>
<pre><code class="language-bash">rustlings verify
</code></pre>
<p>This will do the same as watch, but it&#39;ll quit after running.</p>
<p>In case you want to go by your own order, or want to only verify a single exercise, you can run:</p>
<pre><code class="language-bash">rustlings run myExercise1
</code></pre>
<p>Or simply use the following command to run the next unsolved exercise in the course:</p>
<pre><code class="language-bash">rustlings run next
</code></pre>
<p>In case you get stuck, you can run the following command to get a hint for your
exercise:</p>
<pre><code class="language-bash">rustlings hint myExercise1
</code></pre>
<p>You can also get the hint for the next unsolved exercise with the following command:</p>
<pre><code class="language-bash">rustlings hint next
</code></pre>
<p>To check your progress, you can run the following command:</p>
<pre><code class="language-bash">rustlings list
</code></pre>
<h2 id="testing-yourself">Testing yourself</h2>
<p>After every couple of sections, there will be a quiz that&#39;ll test your knowledge on a bunch of sections at once. These quizzes are found in <code>exercises/quizN.rs</code>.</p>
<h2 id="enabling-rust-analyzer">Enabling <code>rust-analyzer</code></h2>
<p>Run the command <code>rustlings lsp</code> which will generate a <code>rust-project.json</code> at the root of the project, this allows <a href="https://rust-analyzer.github.io/">rust-analyzer</a> to parse each exercise.</p>
<h2 id="continuing-on">Continuing On</h2>
<p>Once you&#39;ve completed Rustlings, put your new knowledge to good use! Continue practicing your Rust skills by building your own projects, contributing to Rustlings, or finding other open-source projects to contribute to.</p>
<h2 id="uninstalling-rustlings">Uninstalling Rustlings</h2>
<p>If you want to remove Rustlings from your system, there are two steps. First, you&#39;ll need to remove the exercises folder that the install script created
for you:</p>
<pre><code class="language-bash"><span class="hljs-built_in">rm</span> -rf rustlings <span class="hljs-comment"># or your custom folder name, if you chose and or renamed it</span>
</code></pre>
<p>Second, run <code>cargo uninstall</code> to remove the <code>rustlings</code> binary:</p>
<pre><code class="language-bash">cargo uninstall rustlings
</code></pre>
<p>Now you should be done!</p>
<h2 id="contributing">Contributing</h2>
<p>See <a href="./CONTRIBUTING.md">CONTRIBUTING.md</a>.</p>
<p>Development-focused discussion about Rustlings happens in the <a href="https://rust-lang.zulipchat.com/#narrow/stream/334454-rustlings"><strong>rustlings</strong> stream</a>
on the <a href="https://rust-lang.zulipchat.com">Rust Project Zulip</a>. Feel free to start a new thread there
if you have ideas or suggestions!</p>
<h2 id="contributors-‚ú®">Contributors ‚ú®</h2>
<p>Thanks goes to the wonderful people listed in <a href="./AUTHORS.md">AUTHORS.md</a> üéâ</p>
</p>
</div>
<div class="slide" id="slide_2">
<p><h1 id="variables">Variables</h1>
<p>In Rust, variables are immutable by default.
When a variable is immutable, once a value is bound to a name, you can‚Äôt change that value.
You can make them mutable by adding <code>mut</code> in front of the variable name.</p>
<h2 id="further-information">Further information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html">Variables and Mutability</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// variables1.rs</span>
<span class="hljs-comment">// Make me compile!</span>
<span class="hljs-comment">// Execute `rustlings hint variables1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    x = <span class="hljs-number">5</span>;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x has the value {}&quot;</span>, x);
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// variables2.rs</span>
<span class="hljs-comment">// Execute `rustlings hint variables2` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>;
    <span class="hljs-keyword">if</span> x == <span class="hljs-number">10</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x is ten!&quot;</span>);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x is not ten!&quot;</span>);
    }
}
</code></pre></p>
</div>
<div class="slide" id="slide_3">
<p><h1 id="functions">Functions</h1>
<p>Here, you&#39;ll learn how to write functions and how the Rust compiler can help you debug errors even
in more complex code.</p>
<h2 id="further-information">Further information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch03-03-how-functions-work.html">How Functions Work</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// functions1.rs</span>
<span class="hljs-comment">// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-title function_ invoke__">call_me</span>();
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// functions2.rs</span>
<span class="hljs-comment">// Execute `rustlings hint functions2` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-title function_ invoke__">call_me</span>(<span class="hljs-number">3</span>);
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">call_me</span>(num:) {
    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..num {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Ring! Call number {}&quot;</span>, i + <span class="hljs-number">1</span>);
    }
}
</code></pre></p>
</div>
<div class="slide" id="slide_4">
<p><h1 id="if">If</h1>
<p><code>if</code>, the most basic (but still surprisingly versatile!) type of control flow, is what you&#39;ll learn here.</p>
<h2 id="further-information">Further information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html#if-expressions">Control Flow - if expressions</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// if1.rs</span>
<span class="hljs-comment">// Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">bigger</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> {
    <span class="hljs-comment">// Complete this function to return the bigger number!</span>
    <span class="hljs-comment">// Do not use:</span>
    <span class="hljs-comment">// - another function call</span>
    <span class="hljs-comment">// - additional variables</span>
}

<span class="hljs-comment">// Don&#x27;t mind this for now :)</span>
<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">ten_is_bigger_than_eight</span>() {
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">10</span>, <span class="hljs-title function_ invoke__">bigger</span>(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>));
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fortytwo_is_bigger_than_thirtytwo</span>() {
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">42</span>, <span class="hljs-title function_ invoke__">bigger</span>(<span class="hljs-number">32</span>, <span class="hljs-number">42</span>));
    }
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// if2.rs</span>

<span class="hljs-comment">// Step 1: Make me compile!</span>
<span class="hljs-comment">// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!</span>
<span class="hljs-comment">// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo_if_fizz</span>(fizzish: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> {
    <span class="hljs-keyword">if</span> fizzish == <span class="hljs-string">&quot;fizz&quot;</span> {
        <span class="hljs-string">&quot;foo&quot;</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-number">1</span>
    }
}

<span class="hljs-comment">// No test changes needed!</span>
<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo_for_fizz</span>() {
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">foo_if_fizz</span>(<span class="hljs-string">&quot;fizz&quot;</span>), <span class="hljs-string">&quot;foo&quot;</span>)
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">bar_for_fuzz</span>() {
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">foo_if_fizz</span>(<span class="hljs-string">&quot;fuzz&quot;</span>), <span class="hljs-string">&quot;bar&quot;</span>)
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">default_to_baz</span>() {
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">foo_if_fizz</span>(<span class="hljs-string">&quot;literally anything&quot;</span>), <span class="hljs-string">&quot;baz&quot;</span>)
    }
}
</code></pre></p>
</div>
<div class="slide" id="slide_5">
<p><h1 id="primitive-types">Primitive Types</h1>
<p>Rust has a couple of basic types that are directly implemented into the
compiler. In this section, we&#39;ll go through the most important ones.</p>
<h2 id="further-information">Further information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/book/ch03-02-data-types.html">Data Types</a></li>
<li><a href="https://doc.rust-lang.org/stable/book/ch04-03-slices.html">The Slice Type</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// primitive_types1.rs</span>
<span class="hljs-comment">// Fill in the rest of the line that has code missing!</span>
<span class="hljs-comment">// No hints, there&#x27;s no tricks, just get used to typing these :)</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-comment">// Booleans (`bool`)</span>

    <span class="hljs-keyword">let</span> <span class="hljs-variable">is_morning</span> = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> is_morning {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Good morning!&quot;</span>);
    }

    <span class="hljs-keyword">let</span> <span class="hljs-comment">// Finish the rest of this line like the example! Or make it be false!</span>
    <span class="hljs-keyword">if</span> is_evening {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Good evening!&quot;</span>);
    }
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// primitive_types2.rs</span>
<span class="hljs-comment">// Fill in the rest of the line that has code missing!</span>
<span class="hljs-comment">// No hints, there&#x27;s no tricks, just get used to typing these :)</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-comment">// Characters (`char`)</span>

    <span class="hljs-comment">// Note the _single_ quotes, these are different from the double quotes</span>
    <span class="hljs-comment">// you&#x27;ve been seeing around.</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">my_first_initial</span> = <span class="hljs-string">&#x27;C&#x27;</span>;
    <span class="hljs-keyword">if</span> my_first_initial.<span class="hljs-title function_ invoke__">is_alphabetic</span>() {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Alphabetical!&quot;</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> my_first_initial.<span class="hljs-title function_ invoke__">is_numeric</span>() {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Numerical!&quot;</span>);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Neither alphabetic nor numeric!&quot;</span>);
    }

    <span class="hljs-keyword">let</span> <span class="hljs-comment">// Finish this line like the example! What&#x27;s your favorite character?</span>
    <span class="hljs-comment">// Try a letter, try a number, try a special character, try a character</span>
    <span class="hljs-comment">// from a different language than your own, try an emoji!</span>
    <span class="hljs-keyword">if</span> your_character.<span class="hljs-title function_ invoke__">is_alphabetic</span>() {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Alphabetical!&quot;</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> your_character.<span class="hljs-title function_ invoke__">is_numeric</span>() {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Numerical!&quot;</span>);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Neither alphabetic nor numeric!&quot;</span>);
    }
}
</code></pre></p>
</div>
<div class="slide" id="slide_6">
<p><h1 id="vectors">Vectors</h1>
<p>Vectors are one of the most-used Rust data structures. In other programming
languages, they&#39;d simply be called Arrays, but since Rust operates on a
bit of a lower level, an array in Rust is stored on the stack (meaning it
can&#39;t grow or shrink, and the size needs to be known at compile time),
and a Vector is stored in the heap (where these restrictions do not apply).</p>
<p>Vectors are a bit of a later chapter in the book, but we think that they&#39;re
useful enough to talk about them a bit earlier. We shall be talking about
the other useful data structure, hash maps, later.</p>
<h2 id="further-information">Further information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/book/ch08-01-vectors.html">Storing Lists of Values with Vectors</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.iter_mut"><code>iter_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map"><code>map</code></a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// vecs1.rs</span>
<span class="hljs-comment">// Your task is to create a `Vec` which holds the exact same elements</span>
<span class="hljs-comment">// as in the array `a`.</span>
<span class="hljs-comment">// Make me compile and pass the test!</span>
<span class="hljs-comment">// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">array_and_vec</span>() <span class="hljs-punctuation">-&gt;</span> ([<span class="hljs-type">i32</span>; <span class="hljs-number">4</span>], <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>]; <span class="hljs-comment">// a plain array</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> declare your vector here with the macro for vectors</span>

    (a, v)
}

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_array_and_vec_similarity</span>() {
        <span class="hljs-keyword">let</span> (a, v) = <span class="hljs-title function_ invoke__">array_and_vec</span>();
        <span class="hljs-built_in">assert_eq!</span>(a, v[..]);
    }
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// vecs2.rs</span>
<span class="hljs-comment">// A Vec of even numbers is given. Your task is to complete the loop</span>
<span class="hljs-comment">// so that each number in the Vec is multiplied by 2.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Make me pass the test!</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">vec_loop</span>(<span class="hljs-keyword">mut</span> v: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; {
    <span class="hljs-keyword">for</span> <span class="hljs-variable">element</span> <span class="hljs-keyword">in</span> v.<span class="hljs-title function_ invoke__">iter_mut</span>() {
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Fill this up so that each element in the Vec `v` is</span>
        <span class="hljs-comment">// multiplied by 2.</span>
        ???
    }

    <span class="hljs-comment">// At this point, `v` should be equal to [4, 8, 12, 16, 20].</span>
    v
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">vec_map</span>(v: &amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; {
    v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|element| {
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Do the same thing as above - but instead of mutating the</span>
        <span class="hljs-comment">// Vec, you can just return the new number!</span>
        ???
    }).<span class="hljs-title function_ invoke__">collect</span>()
}

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_vec_loop</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = (<span class="hljs-number">1</span>..).<span class="hljs-title function_ invoke__">filter</span>(|x| x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">take</span>(<span class="hljs-number">5</span>).<span class="hljs-title function_ invoke__">collect</span>();
        <span class="hljs-keyword">let</span> <span class="hljs-variable">ans</span> = <span class="hljs-title function_ invoke__">vec_loop</span>(v.<span class="hljs-title function_ invoke__">clone</span>());

        <span class="hljs-built_in">assert_eq!</span>(ans, v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|x| x * <span class="hljs-number">2</span>).collect::&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;&gt;());
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_vec_map</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = (<span class="hljs-number">1</span>..).<span class="hljs-title function_ invoke__">filter</span>(|x| x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">take</span>(<span class="hljs-number">5</span>).<span class="hljs-title function_ invoke__">collect</span>();
        <span class="hljs-keyword">let</span> <span class="hljs-variable">ans</span> = <span class="hljs-title function_ invoke__">vec_map</span>(&amp;v);

        <span class="hljs-built_in">assert_eq!</span>(ans, v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|x| x * <span class="hljs-number">2</span>).collect::&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;&gt;());
    }
}
</code></pre></p>
</div>
<div class="slide" id="slide_7">
<p><h1 id="move-semantics">Move Semantics</h1>
<p>These exercises are adapted from <a href="https://github.com/pnkfelix">pnkfelix</a>&#39;s <a href="https://pnkfelix.github.io/rust-examples-icfp2014/">Rust Tutorial</a> -- Thank you Felix!!!</p>
<h2 id="further-information">Further information</h2>
<p>For this section, the book links are especially important.</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">Ownership</a></li>
<li><a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">Reference and borrowing</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// move_semantics1.rs</span>
<span class="hljs-comment">// Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">vec0</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();

    <span class="hljs-keyword">let</span> <span class="hljs-variable">vec1</span> = <span class="hljs-title function_ invoke__">fill_vec</span>(vec0);

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{} has length {} content `{:?}`&quot;</span>, <span class="hljs-string">&quot;vec1&quot;</span>, vec1.<span class="hljs-title function_ invoke__">len</span>(), vec1);

    vec1.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">88</span>);

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{} has length {} content `{:?}`&quot;</span>, <span class="hljs-string">&quot;vec1&quot;</span>, vec1.<span class="hljs-title function_ invoke__">len</span>(), vec1);
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">fill_vec</span>(vec: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">vec</span> = vec;

    vec.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">22</span>);
    vec.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">44</span>);
    vec.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">66</span>);

    vec
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// move_semantics2.rs</span>
<span class="hljs-comment">// Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// Expected output:</span>
<span class="hljs-comment">// vec0 has length 3 content `[22, 44, 66]`</span>
<span class="hljs-comment">// vec1 has length 4 content `[22, 44, 66, 88]`</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">vec0</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();

    <span class="hljs-comment">// Do not move the following line!</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">vec1</span> = <span class="hljs-title function_ invoke__">fill_vec</span>(vec0);

    <span class="hljs-comment">// Do not change the following line!</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{} has length {} content `{:?}`&quot;</span>, <span class="hljs-string">&quot;vec0&quot;</span>, vec0.<span class="hljs-title function_ invoke__">len</span>(), vec0);

    vec1.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">88</span>);

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{} has length {} content `{:?}`&quot;</span>, <span class="hljs-string">&quot;vec1&quot;</span>, vec1.<span class="hljs-title function_ invoke__">len</span>(), vec1);
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">fill_vec</span>(vec: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">vec</span> = vec;

    vec.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">22</span>);
    vec.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">44</span>);
    vec.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">66</span>);

    vec
}
</code></pre></p>
</div>
<div class="slide" id="slide_8">
<p><h1 id="structs">Structs</h1>
<p>Rust has three struct types: a classic C struct, a tuple struct, and a unit struct.</p>
<h2 id="further-information">Further information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html">Structures</a></li>
<li><a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html">Method Syntax</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// structs1.rs</span>
<span class="hljs-comment">// Address all the TODOs to make the tests pass!</span>
<span class="hljs-comment">// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ColorClassicStruct</span> {
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Something goes here</span>
}

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ColorTupleStruct</span>(<span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Something goes here */</span>);

<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">UnitLikeStruct</span>;

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">classic_c_structs</span>() {
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Instantiate a classic c struct!</span>
        <span class="hljs-comment">// let green =</span>

        <span class="hljs-built_in">assert_eq!</span>(green.red, <span class="hljs-number">0</span>);
        <span class="hljs-built_in">assert_eq!</span>(green.green, <span class="hljs-number">255</span>);
        <span class="hljs-built_in">assert_eq!</span>(green.blue, <span class="hljs-number">0</span>);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">tuple_structs</span>() {
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Instantiate a tuple struct!</span>
        <span class="hljs-comment">// let green =</span>

        <span class="hljs-built_in">assert_eq!</span>(green.<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        <span class="hljs-built_in">assert_eq!</span>(green.<span class="hljs-number">1</span>, <span class="hljs-number">255</span>);
        <span class="hljs-built_in">assert_eq!</span>(green.<span class="hljs-number">2</span>, <span class="hljs-number">0</span>);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">unit_structs</span>() {
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Instantiate a unit-like struct!</span>
        <span class="hljs-comment">// let unit_like_struct =</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">message</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;{:?}s are fun!&quot;</span>, unit_like_struct);

        <span class="hljs-built_in">assert_eq!</span>(message, <span class="hljs-string">&quot;UnitLikeStructs are fun!&quot;</span>);
    }
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// structs2.rs</span>
<span class="hljs-comment">// Address all the TODOs to make the tests pass!</span>
<span class="hljs-comment">// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Order</span> {
    name: <span class="hljs-type">String</span>,
    year: <span class="hljs-type">u32</span>,
    made_by_phone: <span class="hljs-type">bool</span>,
    made_by_mobile: <span class="hljs-type">bool</span>,
    made_by_email: <span class="hljs-type">bool</span>,
    item_number: <span class="hljs-type">u32</span>,
    count: <span class="hljs-type">u32</span>,
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">create_order_template</span>() <span class="hljs-punctuation">-&gt;</span> Order {
    Order {
        name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Bob&quot;</span>),
        year: <span class="hljs-number">2019</span>,
        made_by_phone: <span class="hljs-literal">false</span>,
        made_by_mobile: <span class="hljs-literal">false</span>,
        made_by_email: <span class="hljs-literal">true</span>,
        item_number: <span class="hljs-number">123</span>,
        count: <span class="hljs-number">0</span>,
    }
}

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">your_order</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">order_template</span> = <span class="hljs-title function_ invoke__">create_order_template</span>();
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Create your own order using the update syntax and template above!</span>
        <span class="hljs-comment">// let your_order =</span>
        <span class="hljs-built_in">assert_eq!</span>(your_order.name, <span class="hljs-string">&quot;Hacker in Rust&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(your_order.year, order_template.year);
        <span class="hljs-built_in">assert_eq!</span>(your_order.made_by_phone, order_template.made_by_phone);
        <span class="hljs-built_in">assert_eq!</span>(your_order.made_by_mobile, order_template.made_by_mobile);
        <span class="hljs-built_in">assert_eq!</span>(your_order.made_by_email, order_template.made_by_email);
        <span class="hljs-built_in">assert_eq!</span>(your_order.item_number, order_template.item_number);
        <span class="hljs-built_in">assert_eq!</span>(your_order.count, <span class="hljs-number">1</span>);
    }
}
</code></pre></p>
</div>
<div class="slide" id="slide_9">
<p><h1 id="enums">Enums</h1>
<p>Rust allows you to define types called &quot;enums&quot; which enumerate possible values.
Enums are a feature in many languages, but their capabilities differ in each language. Rust‚Äôs enums are most similar to algebraic data types in functional languages, such as F#, OCaml, and Haskell.
Useful in combination with enums is Rust&#39;s &quot;pattern matching&quot; facility, which makes it easy to run different code for different values of an enumeration.</p>
<h2 id="further-information">Further information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch06-00-enums.html">Enums</a></li>
<li><a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html">Pattern syntax</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// enums1.rs</span>
<span class="hljs-comment">// No hints this time! ;)</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span> {
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> define a few types of messages as used below</span>
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{:?}&quot;</span>, Message::Quit);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{:?}&quot;</span>, Message::Echo);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{:?}&quot;</span>, Message::Move);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{:?}&quot;</span>, Message::ChangeColor);
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// enums2.rs</span>
<span class="hljs-comment">// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span> {
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> define the different variants used below</span>
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Message</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">call</span>(&amp;<span class="hljs-keyword">self</span>) {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{:?}&quot;</span>, <span class="hljs-keyword">self</span>);
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">messages</span> = [
        Message::Move { x: <span class="hljs-number">10</span>, y: <span class="hljs-number">30</span> },
        Message::<span class="hljs-title function_ invoke__">Echo</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello world&quot;</span>)),
        Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-number">200</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>),
        Message::Quit,
    ];

    <span class="hljs-keyword">for</span> <span class="hljs-variable">message</span> <span class="hljs-keyword">in</span> &amp;messages {
        message.<span class="hljs-title function_ invoke__">call</span>();
    }
}
</code></pre></p>
</div>
<div class="slide" id="slide_10">
<p><h1 id="strings">Strings</h1>
<p>Rust has two string types, a string slice (<code>&amp;str</code>) and an owned string (<code>String</code>).
We&#39;re not going to dictate when you should use which one, but we&#39;ll show you how
to identify and create them, as well as use them.</p>
<h2 id="further-information">Further information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch08-02-strings.html">Strings</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// strings1.rs</span>
<span class="hljs-comment">// Make me compile without changing the function signature!</span>
<span class="hljs-comment">// Execute `rustlings hint strings1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">answer</span> = <span class="hljs-title function_ invoke__">current_favorite_color</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;My current favorite color is {}&quot;</span>, answer);
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">current_favorite_color</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> {
    <span class="hljs-string">&quot;blue&quot;</span>
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// strings2.rs</span>
<span class="hljs-comment">// Make me compile without changing the function signature!</span>
<span class="hljs-comment">// Execute `rustlings hint strings2` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">word</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;green&quot;</span>); <span class="hljs-comment">// Try not changing this line :)</span>
    <span class="hljs-keyword">if</span> <span class="hljs-title function_ invoke__">is_a_color_word</span>(word) {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;That is a color word I know!&quot;</span>);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;That is not a color word I know.&quot;</span>);
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_a_color_word</span>(attempt: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> {
    attempt == <span class="hljs-string">&quot;green&quot;</span> || attempt == <span class="hljs-string">&quot;blue&quot;</span> || attempt == <span class="hljs-string">&quot;red&quot;</span>
}
</code></pre></p>
</div>
<div class="slide" id="slide_11">
<p><h1 id="modules">Modules</h1>
<p>In this section we&#39;ll give you an introduction to Rust&#39;s module system.</p>
<h2 id="further-information">Further information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">The Module System</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// modules1.rs</span>
<span class="hljs-comment">// Execute `rustlings hint modules1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">mod</span> sausage_factory {
    <span class="hljs-comment">// Don&#x27;t let anybody outside of this module see this!</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_secret_recipe</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> {
        <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Ginger&quot;</span>)
    }

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">make_sausage</span>() {
        <span class="hljs-title function_ invoke__">get_secret_recipe</span>();
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;sausage!&quot;</span>);
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    sausage_factory::<span class="hljs-title function_ invoke__">make_sausage</span>();
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// modules2.rs</span>
<span class="hljs-comment">// You can bring module paths into scopes and provide new names for them with the</span>
<span class="hljs-comment">// &#x27;use&#x27; and &#x27;as&#x27; keywords. Fix these &#x27;use&#x27; statements to make the code compile.</span>
<span class="hljs-comment">// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">mod</span> delicious_snacks {
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Fix these use statements</span>
    <span class="hljs-keyword">use</span> self::fruits::PEAR <span class="hljs-keyword">as</span> ???
    <span class="hljs-keyword">use</span> self::veggies::CUCUMBER <span class="hljs-keyword">as</span> ???

    <span class="hljs-keyword">mod</span> fruits {
        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">const</span> PEAR: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Pear&quot;</span>;
        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">const</span> APPLE: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Apple&quot;</span>;
    }

    <span class="hljs-keyword">mod</span> veggies {
        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">const</span> CUCUMBER: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Cucumber&quot;</span>;
        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">const</span> CARROT: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Carrot&quot;</span>;
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-built_in">println!</span>(
        <span class="hljs-string">&quot;favorite snacks: {} and {}&quot;</span>,
        delicious_snacks::fruit,
        delicious_snacks::veggie
    );
}
</code></pre></p>
</div>
<div class="slide" id="slide_12">
<p><h1 id="hashmaps">Hashmaps</h1>
<p>A <em>hash map</em> allows you to associate a value with a particular key.
You may also know this by the names <a href="https://en.cppreference.com/w/cpp/container/unordered_map"><em>unordered map</em> in C++</a>,
<a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries"><em>dictionary</em> in Python</a> or an <em>associative array</em> in other languages.</p>
<p>This is the other data structure that we&#39;ve been talking about before, when
talking about Vecs.</p>
<h2 id="further-information">Further information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch08-03-hash-maps.html">Storing Keys with Associated Values in Hash Maps</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// hashmaps1.rs</span>
<span class="hljs-comment">// A basket of fruits in the form of a hash map needs to be defined.</span>
<span class="hljs-comment">// The key represents the name of the fruit and the value represents</span>
<span class="hljs-comment">// how many of that particular fruit is in the basket. You have to put</span>
<span class="hljs-comment">// at least three different types of fruits (e.g apple, banana, mango)</span>
<span class="hljs-comment">// in the basket and the total count of all the fruits should be at</span>
<span class="hljs-comment">// least five.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Make me compile and pass the tests!</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Execute `rustlings hint hashmaps1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">use</span> std::collections::HashMap;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">fruit_basket</span>() <span class="hljs-punctuation">-&gt;</span> HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">u32</span>&gt; {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">basket</span> = <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> declare your hash map here.</span>

    <span class="hljs-comment">// Two bananas are already given for you :)</span>
    basket.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;banana&quot;</span>), <span class="hljs-number">2</span>);

    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Put more fruits in your basket here.</span>

    basket
}

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">at_least_three_types_of_fruits</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">basket</span> = <span class="hljs-title function_ invoke__">fruit_basket</span>();
        <span class="hljs-built_in">assert!</span>(basket.<span class="hljs-title function_ invoke__">len</span>() &gt;= <span class="hljs-number">3</span>);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">at_least_five_fruits</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">basket</span> = <span class="hljs-title function_ invoke__">fruit_basket</span>();
        <span class="hljs-built_in">assert!</span>(basket.<span class="hljs-title function_ invoke__">values</span>().sum::&lt;<span class="hljs-type">u32</span>&gt;() &gt;= <span class="hljs-number">5</span>);
    }
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// hashmaps2.rs</span>
<span class="hljs-comment">// We&#x27;re collecting different fruits to bake a delicious fruit cake.</span>
<span class="hljs-comment">// For this, we have a basket, which we&#x27;ll represent in the form of a hash</span>
<span class="hljs-comment">// map. The key represents the name of each fruit we collect and the value</span>
<span class="hljs-comment">// represents how many of that particular fruit we have collected.</span>
<span class="hljs-comment">// Three types of fruits - Apple (4), Mango (2) and Lychee (5) are already</span>
<span class="hljs-comment">// in the basket hash map.</span>
<span class="hljs-comment">// You must add fruit to the basket so that there is at least</span>
<span class="hljs-comment">// one of each kind and more than 11 in total - we have a lot of mouths to feed.</span>
<span class="hljs-comment">// You are not allowed to insert any more of these fruits!</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Make me pass the tests!</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">use</span> std::collections::HashMap;

<span class="hljs-meta">#[derive(Hash, PartialEq, Eq)]</span>
<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Fruit</span> {
    Apple,
    Banana,
    Mango,
    Lychee,
    Pineapple,
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">fruit_basket</span>(basket: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;Fruit, <span class="hljs-type">u32</span>&gt;) {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">fruit_kinds</span> = <span class="hljs-built_in">vec!</span>[
        Fruit::Apple,
        Fruit::Banana,
        Fruit::Mango,
        Fruit::Lychee,
        Fruit::Pineapple,
    ];

    <span class="hljs-keyword">for</span> <span class="hljs-variable">fruit</span> <span class="hljs-keyword">in</span> fruit_kinds {
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Insert new fruits if they are not already present in the basket.</span>
        <span class="hljs-comment">// Note that you are not allowed to put any type of fruit that&#x27;s already</span>
        <span class="hljs-comment">// present!</span>
    }
}

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-comment">// Don&#x27;t modify this function!</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_fruit_basket</span>() <span class="hljs-punctuation">-&gt;</span> HashMap&lt;Fruit, <span class="hljs-type">u32</span>&gt; {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">basket</span> = HashMap::&lt;Fruit, <span class="hljs-type">u32</span>&gt;::<span class="hljs-title function_ invoke__">new</span>();
        basket.<span class="hljs-title function_ invoke__">insert</span>(Fruit::Apple, <span class="hljs-number">4</span>);
        basket.<span class="hljs-title function_ invoke__">insert</span>(Fruit::Mango, <span class="hljs-number">2</span>);
        basket.<span class="hljs-title function_ invoke__">insert</span>(Fruit::Lychee, <span class="hljs-number">5</span>);

        basket
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_given_fruits_are_not_modified</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">basket</span> = <span class="hljs-title function_ invoke__">get_fruit_basket</span>();
        <span class="hljs-title function_ invoke__">fruit_basket</span>(&amp;<span class="hljs-keyword">mut</span> basket);
        <span class="hljs-built_in">assert_eq!</span>(*basket.<span class="hljs-title function_ invoke__">get</span>(&amp;Fruit::Apple).<span class="hljs-title function_ invoke__">unwrap</span>(), <span class="hljs-number">4</span>);
        <span class="hljs-built_in">assert_eq!</span>(*basket.<span class="hljs-title function_ invoke__">get</span>(&amp;Fruit::Mango).<span class="hljs-title function_ invoke__">unwrap</span>(), <span class="hljs-number">2</span>);
        <span class="hljs-built_in">assert_eq!</span>(*basket.<span class="hljs-title function_ invoke__">get</span>(&amp;Fruit::Lychee).<span class="hljs-title function_ invoke__">unwrap</span>(), <span class="hljs-number">5</span>);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">at_least_five_types_of_fruits</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">basket</span> = <span class="hljs-title function_ invoke__">get_fruit_basket</span>();
        <span class="hljs-title function_ invoke__">fruit_basket</span>(&amp;<span class="hljs-keyword">mut</span> basket);
        <span class="hljs-keyword">let</span> <span class="hljs-variable">count_fruit_kinds</span> = basket.<span class="hljs-title function_ invoke__">len</span>();
        <span class="hljs-built_in">assert!</span>(count_fruit_kinds &gt;= <span class="hljs-number">5</span>);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">greater_than_eleven_fruits</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">basket</span> = <span class="hljs-title function_ invoke__">get_fruit_basket</span>();
        <span class="hljs-title function_ invoke__">fruit_basket</span>(&amp;<span class="hljs-keyword">mut</span> basket);
        <span class="hljs-keyword">let</span> <span class="hljs-variable">count</span> = basket.<span class="hljs-title function_ invoke__">values</span>().sum::&lt;<span class="hljs-type">u32</span>&gt;();
        <span class="hljs-built_in">assert!</span>(count &gt; <span class="hljs-number">11</span>);
    }
}
</code></pre></p>
</div>
<div class="slide" id="slide_13">
<p><h1 id="options">Options</h1>
<p>Type Option represents an optional value: every Option is either Some and contains a value, or None, and does not.
Option types are very common in Rust code, as they have a number of uses:</p>
<ul>
<li>Initial values</li>
<li>Return values for functions that are not defined over their entire input range (partial functions)</li>
<li>Return value for otherwise reporting simple errors, where None is returned on error</li>
<li>Optional struct fields</li>
<li>Struct fields that can be loaned or &quot;taken&quot;</li>
<li>Optional function arguments</li>
<li>Nullable pointers</li>
<li>Swapping things out of difficult situations</li>
</ul>
<h2 id="further-information">Further Information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/book/ch10-01-syntax.html#in-enum-definitions">Option Enum Format</a></li>
<li><a href="https://doc.rust-lang.org/std/option/">Option Module Documentation</a></li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html">Option Enum Documentation</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html">if let</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/flow_control/while_let.html">while let</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// options1.rs</span>
<span class="hljs-comment">// Execute `rustlings hint options1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-comment">// This function returns how much icecream there is left in the fridge.</span>
<span class="hljs-comment">// If it&#x27;s before 10PM, there&#x27;s 5 pieces left. At 10PM, someone eats them</span>
<span class="hljs-comment">// all, so there&#x27;ll be no more left :(</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">maybe_icecream</span>(time_of_day: <span class="hljs-type">u16</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u16</span>&gt; {
    <span class="hljs-comment">// We use the 24-hour system here, so 10PM is a value of 22 and 12AM is a value of 0</span>
    <span class="hljs-comment">// The Option output should gracefully handle cases where time_of_day &gt; 23.</span>
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Complete the function body - remember to return an Option!</span>
    ???
}

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">check_icecream</span>() {
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">maybe_icecream</span>(<span class="hljs-number">9</span>), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>));
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">maybe_icecream</span>(<span class="hljs-number">10</span>), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>));
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">maybe_icecream</span>(<span class="hljs-number">23</span>), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">0</span>));
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">maybe_icecream</span>(<span class="hljs-number">22</span>), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">0</span>));
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">maybe_icecream</span>(<span class="hljs-number">25</span>), <span class="hljs-literal">None</span>);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">raw_value</span>() {
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Fix this test. How do you get at the value contained in the Option?</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">icecreams</span> = <span class="hljs-title function_ invoke__">maybe_icecream</span>(<span class="hljs-number">12</span>);
        <span class="hljs-built_in">assert_eq!</span>(icecreams, <span class="hljs-number">5</span>);
    }
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// options2.rs</span>
<span class="hljs-comment">// Execute `rustlings hint options2` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">simple_option</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">target</span> = <span class="hljs-string">&quot;rustlings&quot;</span>;
        <span class="hljs-keyword">let</span> <span class="hljs-variable">optional_target</span> = <span class="hljs-title function_ invoke__">Some</span>(target);

        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Make this an if let statement whose value is &quot;Some&quot; type</span>
        word = optional_target {
            <span class="hljs-built_in">assert_eq!</span>(word, target);
        }
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">layered_option</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">range</span> = <span class="hljs-number">10</span>;
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">optional_integers</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Option</span>&lt;<span class="hljs-type">i8</span>&gt;&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();
        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..(range + <span class="hljs-number">1</span>) {
            optional_integers.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-title function_ invoke__">Some</span>(i));
        }

        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> make this a while let statement - remember that vector.pop also adds another layer of Option&lt;T&gt;</span>
        <span class="hljs-comment">// You can stack `Option&lt;T&gt;`&#x27;s into while let and if let</span>
        integer = optional_integers.<span class="hljs-title function_ invoke__">pop</span>() {
            <span class="hljs-built_in">assert_eq!</span>(integer, range);
            range -= <span class="hljs-number">1</span>;
        }
    }
}
</code></pre></p>
</div>
<div class="slide" id="slide_14">
<p><h1 id="error-handling">Error handling</h1>
<p>Most errors aren‚Äôt serious enough to require the program to stop entirely.
Sometimes, when a function fails, it‚Äôs for a reason that you can easily interpret and respond to.
For example, if you try to open a file and that operation fails because the file doesn‚Äôt exist, you might want to create the file instead of terminating the process.</p>
<h2 id="further-information">Further information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html">Error Handling</a></li>
<li><a href="https://doc.rust-lang.org/book/ch10-01-syntax.html">Generics</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/error/result.html">Result</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/error/multiple_error_types/boxing_errors.html">Boxing errors</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// errors1.rs</span>
<span class="hljs-comment">// This function refuses to generate text to be printed on a nametag if</span>
<span class="hljs-comment">// you pass it an empty string. It&#x27;d be nicer if it explained what the problem</span>
<span class="hljs-comment">// was, instead of just sometimes returning `None`. Thankfully, Rust has a similar</span>
<span class="hljs-comment">// construct to `Option` that can be used to express error conditions. Let&#x27;s use it!</span>
<span class="hljs-comment">// Execute `rustlings hint errors1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">generate_nametag_text</span>(name: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt; {
    <span class="hljs-keyword">if</span> name.<span class="hljs-title function_ invoke__">is_empty</span>() {
        <span class="hljs-comment">// Empty names aren&#x27;t allowed.</span>
        <span class="hljs-literal">None</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;Hi! My name is {}&quot;</span>, name))
    }
}

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">generates_nametag_text_for_a_nonempty_name</span>() {
        <span class="hljs-built_in">assert_eq!</span>(
            <span class="hljs-title function_ invoke__">generate_nametag_text</span>(<span class="hljs-string">&quot;Beyonc√©&quot;</span>.<span class="hljs-title function_ invoke__">into</span>()),
            <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-string">&quot;Hi! My name is Beyonc√©&quot;</span>.<span class="hljs-title function_ invoke__">into</span>())
        );
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">explains_why_generating_nametag_text_fails</span>() {
        <span class="hljs-built_in">assert_eq!</span>(
            <span class="hljs-title function_ invoke__">generate_nametag_text</span>(<span class="hljs-string">&quot;&quot;</span>.<span class="hljs-title function_ invoke__">into</span>()),
            <span class="hljs-comment">// Don&#x27;t change this line</span>
            <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-string">&quot;`name` was empty; it must be nonempty.&quot;</span>.<span class="hljs-title function_ invoke__">into</span>())
        );
    }
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// errors2.rs</span>
<span class="hljs-comment">// Say we&#x27;re writing a game where you can buy items with tokens. All items cost</span>
<span class="hljs-comment">// 5 tokens, and whenever you purchase items there is a processing fee of 1</span>
<span class="hljs-comment">// token. A player of the game will type in how many items they want to buy,</span>
<span class="hljs-comment">// and the `total_cost` function will calculate the total cost of the tokens.</span>
<span class="hljs-comment">// Since the player typed in the quantity, though, we get it as a string-- and</span>
<span class="hljs-comment">// they might have typed anything, not just numbers!</span>

<span class="hljs-comment">// Right now, this function isn&#x27;t handling the error case at all (and isn&#x27;t</span>
<span class="hljs-comment">// handling the success case properly either). What we want to do is:</span>
<span class="hljs-comment">// if we call the `parse` function on a string that is not a number, that</span>
<span class="hljs-comment">// function will return a `ParseIntError`, and in that case, we want to</span>
<span class="hljs-comment">// immediately return that error from our function and not try to multiply</span>
<span class="hljs-comment">// and add.</span>

<span class="hljs-comment">// There are at least two ways to implement this that are both correct-- but</span>
<span class="hljs-comment">// one is a lot shorter!</span>
<span class="hljs-comment">// Execute `rustlings hint errors2` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">use</span> std::num::ParseIntError;

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">total_cost</span>(item_quantity: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">i32</span>, ParseIntError&gt; {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">processing_fee</span> = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">cost_per_item</span> = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">qty</span> = item_quantity.parse::&lt;<span class="hljs-type">i32</span>&gt;();

    <span class="hljs-title function_ invoke__">Ok</span>(qty * cost_per_item + processing_fee)
}

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">item_quantity_is_a_valid_number</span>() {
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">total_cost</span>(<span class="hljs-string">&quot;34&quot;</span>), <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-number">171</span>));
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">item_quantity_is_an_invalid_number</span>() {
        <span class="hljs-built_in">assert_eq!</span>(
            <span class="hljs-title function_ invoke__">total_cost</span>(<span class="hljs-string">&quot;beep boop&quot;</span>).<span class="hljs-title function_ invoke__">unwrap_err</span>().<span class="hljs-title function_ invoke__">to_string</span>(),
            <span class="hljs-string">&quot;invalid digit found in string&quot;</span>
        );
    }
}
</code></pre></p>
</div>
<div class="slide" id="slide_15">
<p><h1 id="generics">Generics</h1>
<p>Generics is the topic of generalizing types and functionalities to broader cases.
This is extremely useful for reducing code duplication in many ways, but can call for rather involving syntax.
Namely, being generic requires taking great care to specify over which types a generic type is actually considered valid.
The simplest and most common use of generics is for type parameters.</p>
<h2 id="further-information">Further information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/book/ch10-01-syntax.html">Generic Data Types</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/generics/bounds.html">Bounds</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// This shopping list program isn&#x27;t compiling!</span>
<span class="hljs-comment">// Use your knowledge of generics to fix it.</span>

<span class="hljs-comment">// Execute `rustlings hint generics1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">shopping_list</span>: <span class="hljs-type">Vec</span>&lt;?&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();
    shopping_list.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-string">&quot;milk&quot;</span>);
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// This powerful wrapper provides the ability to store a positive integer value.</span>
<span class="hljs-comment">// Rewrite it using generics so that it supports wrapping ANY type.</span>

<span class="hljs-comment">// Execute `rustlings hint generics2` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Wrapper</span> {
    value: <span class="hljs-type">u32</span>,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Wrapper</span> {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(value: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> {
        Wrapper { value }
    }
}

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">store_u32_in_wrapper</span>() {
        <span class="hljs-built_in">assert_eq!</span>(Wrapper::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>).value, <span class="hljs-number">42</span>);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">store_str_in_wrapper</span>() {
        <span class="hljs-built_in">assert_eq!</span>(Wrapper::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;Foo&quot;</span>).value, <span class="hljs-string">&quot;Foo&quot;</span>);
    }
}
</code></pre></p>
</div>
<div class="slide" id="slide_16">
<p><h1 id="traits">Traits</h1>
<p>A trait is a collection of methods.</p>
<p>Data types can implement traits. To do so, the methods making up the trait are defined for the data type. For example, the <code>String</code> data type implements the <code>From&lt;&amp;str&gt;</code> trait. This allows a user to write <code>String::from(&quot;hello&quot;)</code>.</p>
<p>In this way, traits are somewhat similar to Java interfaces and C++ abstract classes.</p>
<p>Some additional common Rust traits include:</p>
<ul>
<li><code>Clone</code> (the <code>clone</code> method)</li>
<li><code>Display</code> (which allows formatted display via <code>{}</code>)</li>
<li><code>Debug</code> (which allows formatted display via <code>{:?}</code>)</li>
</ul>
<p>Because traits indicate shared behavior between data types, they are useful when writing generics.</p>
<h2 id="further-information">Further information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch10-02-traits.html">Traits</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// traits1.rs</span>
<span class="hljs-comment">// Time to implement some traits!</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Your task is to implement the trait</span>
<span class="hljs-comment">// `AppendBar` for the type `String`.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// The trait AppendBar has only one function,</span>
<span class="hljs-comment">// which appends &quot;Bar&quot; to any object</span>
<span class="hljs-comment">// implementing this trait.</span>
<span class="hljs-comment">// Execute `rustlings hint traits1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">trait</span> <span class="hljs-title class_">AppendBar</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">append_bar</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>;
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">AppendBar</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">String</span> {
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement `AppendBar` for type `String`.</span>
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Foo&quot;</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = s.<span class="hljs-title function_ invoke__">append_bar</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;s: {}&quot;</span>, s);
}

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_foo_bar</span>() {
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Foo&quot;</span>).<span class="hljs-title function_ invoke__">append_bar</span>(), <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;FooBar&quot;</span>));
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_bar_bar</span>() {
        <span class="hljs-built_in">assert_eq!</span>(
            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_ invoke__">append_bar</span>().<span class="hljs-title function_ invoke__">append_bar</span>(),
            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;BarBar&quot;</span>)
        );
    }
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// traits2.rs</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Your task is to implement the trait</span>
<span class="hljs-comment">// `AppendBar` for a vector of strings.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// To implement this trait, consider for</span>
<span class="hljs-comment">// a moment what it means to &#x27;append &quot;Bar&quot;&#x27;</span>
<span class="hljs-comment">// to a vector of strings.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// No boiler plate code this time,</span>
<span class="hljs-comment">// you can do this!</span>
<span class="hljs-comment">// Execute `rustlings hint traits2` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">trait</span> <span class="hljs-title class_">AppendBar</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">append_bar</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>;
}

<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement trait `AppendBar` for a vector of strings.</span>

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_vec_pop_eq_bar</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">foo</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Foo&quot;</span>)].<span class="hljs-title function_ invoke__">append_bar</span>();
        <span class="hljs-built_in">assert_eq!</span>(foo.<span class="hljs-title function_ invoke__">pop</span>().<span class="hljs-title function_ invoke__">unwrap</span>(), <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Bar&quot;</span>));
        <span class="hljs-built_in">assert_eq!</span>(foo.<span class="hljs-title function_ invoke__">pop</span>().<span class="hljs-title function_ invoke__">unwrap</span>(), <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Foo&quot;</span>));
    }
}
</code></pre></p>
</div>
<div class="slide" id="slide_17">
<p><h1 id="tests">Tests</h1>
<p>Going out of order from the book to cover tests -- many of the following exercises will ask you to make tests pass!</p>
<h2 id="further-information">Further information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html">Writing Tests</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// tests1.rs</span>
<span class="hljs-comment">// Tests are important to ensure that your code does what you think it should do.</span>
<span class="hljs-comment">// Tests can be run on this file with the following command:</span>
<span class="hljs-comment">// rustlings run tests1</span>

<span class="hljs-comment">// This test has a problem with it -- make the test compile! Make the test</span>
<span class="hljs-comment">// pass! Make the test fail!</span>
<span class="hljs-comment">// Execute `rustlings hint tests1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">you_can_assert</span>() {
        <span class="hljs-built_in">assert!</span>();
    }
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// tests2.rs</span>
<span class="hljs-comment">// This test has a problem with it -- make the test compile! Make the test</span>
<span class="hljs-comment">// pass! Make the test fail!</span>
<span class="hljs-comment">// Execute `rustlings hint tests2` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">you_can_assert_eq</span>() {
        <span class="hljs-built_in">assert_eq!</span>();
    }
}
</code></pre></p>
</div>
<div class="slide" id="slide_18">
<p><h1 id="lifetimes">Lifetimes</h1>
<p>Lifetimes tell the compiler how to check whether references live long
enough to be valid in any given situation. For example lifetimes say
&quot;make sure parameter &#39;a&#39; lives as long as parameter &#39;b&#39; so that the return
value is valid&quot;.</p>
<p>They are only necessary on borrows, i.e. references,
since copied parameters or moves are owned in their scope and cannot
be referenced outside. Lifetimes mean that calling code of e.g. functions
can be checked to make sure their arguments are valid. Lifetimes are
restrictive of their callers.</p>
<p>If you&#39;d like to learn more about lifetime annotations, the
<a href="https://tfpk.github.io/lifetimekata/">lifetimekata</a> project
has a similar style of exercises to Rustlings, but is all about
learning to write lifetime annotations.</p>
<h2 id="further-information">Further information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/scope/lifetime.html">Lifetimes (in Rust By Example)</a></li>
<li><a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html">Validating References with Lifetimes</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// lifetimes1.rs</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// The Rust compiler needs to know how to check whether supplied references are</span>
<span class="hljs-comment">// valid, so that it can let the programmer know if a reference is at risk</span>
<span class="hljs-comment">// of going out of scope before it is used. Remember, references are borrows</span>
<span class="hljs-comment">// and do not own their own data. What if their owner goes out of scope?</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Execute `rustlings hint lifetimes1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>(x: &amp;<span class="hljs-type">str</span>, y: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> {
    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() {
        x
    } <span class="hljs-keyword">else</span> {
        y
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">string1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;abcd&quot;</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">string2</span> = <span class="hljs-string">&quot;xyz&quot;</span>;

    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">longest</span>(string1.<span class="hljs-title function_ invoke__">as_str</span>(), string2);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The longest string is &#x27;{}&#x27;&quot;</span>, result);
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// lifetimes2.rs</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// So if the compiler is just validating the references passed</span>
<span class="hljs-comment">// to the annotated parameters and the return type, what do</span>
<span class="hljs-comment">// we need to change?</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Execute `rustlings hint lifetimes2` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> {
    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() {
        x
    } <span class="hljs-keyword">else</span> {
        y
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">string1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;long string is long&quot;</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span>;
    {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">string2</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;xyz&quot;</span>);
        result = <span class="hljs-title function_ invoke__">longest</span>(string1.<span class="hljs-title function_ invoke__">as_str</span>(), string2.<span class="hljs-title function_ invoke__">as_str</span>());
    }
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The longest string is &#x27;{}&#x27;&quot;</span>, result);
}
</code></pre></p>
</div>
<div class="slide" id="slide_19">
<p><h1 id="iterators">Iterators</h1>
<p>This section will teach you about Iterators.</p>
<h2 id="further-information">Further information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">Iterator</a></li>
<li><a href="https://doc.rust-lang.org/stable/std/iter/">Iterator documentation</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// iterators1.rs</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//  Make me compile by filling in the `???`s</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// When performing operations on elements within a collection, iterators are essential.</span>
<span class="hljs-comment">// This module helps you get familiar with the structure of using an iterator and</span>
<span class="hljs-comment">// how to go through elements within an iterable collection.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Execute `rustlings hint iterators1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">my_fav_fruits</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;custard apple&quot;</span>, <span class="hljs-string">&quot;avocado&quot;</span>, <span class="hljs-string">&quot;peach&quot;</span>, <span class="hljs-string">&quot;raspberry&quot;</span>];

    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">my_iterable_fav_fruits</span> = ???;   <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Step 1</span>

    <span class="hljs-built_in">assert_eq!</span>(my_iterable_fav_fruits.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-title function_ invoke__">Some</span>(&amp;<span class="hljs-string">&quot;banana&quot;</span>));
    <span class="hljs-built_in">assert_eq!</span>(my_iterable_fav_fruits.<span class="hljs-title function_ invoke__">next</span>(), ???);     <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Step 2</span>
    <span class="hljs-built_in">assert_eq!</span>(my_iterable_fav_fruits.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-title function_ invoke__">Some</span>(&amp;<span class="hljs-string">&quot;avocado&quot;</span>));
    <span class="hljs-built_in">assert_eq!</span>(my_iterable_fav_fruits.<span class="hljs-title function_ invoke__">next</span>(), ???);     <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Step 3</span>
    <span class="hljs-built_in">assert_eq!</span>(my_iterable_fav_fruits.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-title function_ invoke__">Some</span>(&amp;<span class="hljs-string">&quot;raspberry&quot;</span>));
    <span class="hljs-built_in">assert_eq!</span>(my_iterable_fav_fruits.<span class="hljs-title function_ invoke__">next</span>(), ???);     <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Step 4</span>
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// iterators2.rs</span>
<span class="hljs-comment">// In this exercise, you&#x27;ll learn some of the unique advantages that iterators</span>
<span class="hljs-comment">// can offer. Follow the steps to complete the exercise.</span>
<span class="hljs-comment">// Execute `rustlings hint iterators2` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-comment">// Step 1.</span>
<span class="hljs-comment">// Complete the `capitalize_first` function.</span>
<span class="hljs-comment">// &quot;hello&quot; -&gt; &quot;Hello&quot;</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">capitalize_first</span>(input: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">c</span> = input.<span class="hljs-title function_ invoke__">chars</span>();
    <span class="hljs-keyword">match</span> c.<span class="hljs-title function_ invoke__">next</span>() {
        <span class="hljs-literal">None</span> =&gt; <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>(),
        <span class="hljs-title function_ invoke__">Some</span>(first) =&gt; ???,
    }
}

<span class="hljs-comment">// Step 2.</span>
<span class="hljs-comment">// Apply the `capitalize_first` function to a slice of string slices.</span>
<span class="hljs-comment">// Return a vector of strings.</span>
<span class="hljs-comment">// [&quot;hello&quot;, &quot;world&quot;] -&gt; [&quot;Hello&quot;, &quot;World&quot;]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">capitalize_words_vector</span>(words: &amp;[&amp;<span class="hljs-type">str</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; {
    <span class="hljs-built_in">vec!</span>[]
}

<span class="hljs-comment">// Step 3.</span>
<span class="hljs-comment">// Apply the `capitalize_first` function again to a slice of string slices.</span>
<span class="hljs-comment">// Return a single string.</span>
<span class="hljs-comment">// [&quot;hello&quot;, &quot; &quot;, &quot;world&quot;] -&gt; &quot;Hello World&quot;</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">capitalize_words_string</span>(words: &amp;[&amp;<span class="hljs-type">str</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> {
    <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>()
}

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_success</span>() {
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">capitalize_first</span>(<span class="hljs-string">&quot;hello&quot;</span>), <span class="hljs-string">&quot;Hello&quot;</span>);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_empty</span>() {
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">capitalize_first</span>(<span class="hljs-string">&quot;&quot;</span>), <span class="hljs-string">&quot;&quot;</span>);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_iterate_string_vec</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">words</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>];
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">capitalize_words_vector</span>(&amp;words), [<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>]);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_iterate_into_string</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">words</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;world&quot;</span>];
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">capitalize_words_string</span>(&amp;words), <span class="hljs-string">&quot;Hello World&quot;</span>);
    }
}
</code></pre></p>
</div>
<div class="slide" id="slide_20">
<p><h1 id="threads">Threads</h1>
<p>In most current operating systems, an executed program‚Äôs code is run in a process, and the operating system manages multiple processes at once.
Within your program, you can also have independent parts that run simultaneously. The features that run these independent parts are called threads.</p>
<h2 id="further-information">Further information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/1.4.0/book/dining-philosophers.html">Dining Philosophers example</a></li>
<li><a href="https://doc.rust-lang.org/book/ch16-01-threads.html">Using Threads to Run Code Simultaneously</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// threads1.rs</span>
<span class="hljs-comment">// Execute `rustlings hint threads1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// This program spawns multiple threads that each run for at least 250ms,</span>
<span class="hljs-comment">// and each thread returns how much time they took to complete.</span>
<span class="hljs-comment">// The program should wait until all the spawned threads have finished and</span>
<span class="hljs-comment">// should collect their return values into a vector.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">use</span> std::thread;
<span class="hljs-keyword">use</span> std::time::{Duration, Instant};

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handles</span> = <span class="hljs-built_in">vec!</span>[];
    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> {
        handles.<span class="hljs-title function_ invoke__">push</span>(thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || {
            <span class="hljs-keyword">let</span> <span class="hljs-variable">start</span> = Instant::<span class="hljs-title function_ invoke__">now</span>();
            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">250</span>));
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;thread {} is complete&quot;</span>, i);
            start.<span class="hljs-title function_ invoke__">elapsed</span>().<span class="hljs-title function_ invoke__">as_millis</span>()
        }));
    }

    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">results</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u128</span>&gt; = <span class="hljs-built_in">vec!</span>[];
    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> handles {
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> a struct is returned from thread::spawn, can you use it?</span>
    }

    <span class="hljs-keyword">if</span> results.<span class="hljs-title function_ invoke__">len</span>() != <span class="hljs-number">10</span> {
        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Oh no! All the spawned threads did not finish!&quot;</span>);
    }

    <span class="hljs-built_in">println!</span>();
    <span class="hljs-title function_ invoke__">for</span> (i, result) <span class="hljs-keyword">in</span> results.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;thread {} took {}ms&quot;</span>, i, result);
    }
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// threads2.rs</span>
<span class="hljs-comment">// Execute `rustlings hint threads2` or use the `hint` watch subcommand for a hint.</span>
<span class="hljs-comment">// Building on the last exercise, we want all of the threads to complete their work but this time</span>
<span class="hljs-comment">// the spawned threads need to be in charge of updating a shared value: JobStatus.jobs_completed</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">use</span> std::sync::Arc;
<span class="hljs-keyword">use</span> std::thread;
<span class="hljs-keyword">use</span> std::time::Duration;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">JobStatus</span> {
    jobs_completed: <span class="hljs-type">u32</span>,
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">status</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(JobStatus { jobs_completed: <span class="hljs-number">0</span> });
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handles</span> = <span class="hljs-built_in">vec!</span>[];
    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">status_shared</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;status);
        <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || {
            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">250</span>));
            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> You must take an action before you update a shared value</span>
            status_shared.jobs_completed += <span class="hljs-number">1</span>;
        });
        handles.<span class="hljs-title function_ invoke__">push</span>(handle);
    }
    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> handles {
        handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Print the value of the JobStatus.jobs_completed. Did you notice anything</span>
        <span class="hljs-comment">// interesting in the output? Do you have to &#x27;join&#x27; on all the handles?</span>
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;jobs completed {}&quot;</span>, ???);
    }
}
</code></pre></p>
</div>
<div class="slide" id="slide_21">
<p><h1 id="smart-pointers">Smart Pointers</h1>
<p>In Rust, smart pointers are variables that contain an address in memory and reference some other data, but they also have additional metadata and capabilities.
Smart pointers in Rust often own the data they point to, while references only borrow data.</p>
<h2 id="further-information">Further Information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch15-00-smart-pointers.html">Smart Pointers</a></li>
<li><a href="https://doc.rust-lang.org/book/ch15-01-box.html">Using Box to Point to Data on the Heap</a></li>
<li><a href="https://doc.rust-lang.org/book/ch15-04-rc.html">Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li>
<li><a href="https://doc.rust-lang.org/book/ch16-03-shared-state.html">Shared-State Concurrency</a></li>
<li><a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html">Cow Documentation</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// arc1.rs</span>
<span class="hljs-comment">// In this exercise, we are given a Vec of u32 called &quot;numbers&quot; with values ranging</span>
<span class="hljs-comment">// from 0 to 99 -- [ 0, 1, 2, ..., 98, 99 ]</span>
<span class="hljs-comment">// We would like to use this set of numbers within 8 different threads simultaneously.</span>
<span class="hljs-comment">// Each thread is going to get the sum of every eighth value, with an offset.</span>
<span class="hljs-comment">// The first thread (offset 0), will sum 0, 8, 16, ...</span>
<span class="hljs-comment">// The second thread (offset 1), will sum 1, 9, 17, ...</span>
<span class="hljs-comment">// The third thread (offset 2), will sum 2, 10, 18, ...</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-comment">// The eighth thread (offset 7), will sum 7, 15, 23, ...</span>

<span class="hljs-comment">// Because we are using threads, our values need to be thread-safe.  Therefore,</span>
<span class="hljs-comment">// we are using Arc.  We need to make a change in each of the two TODOs.</span>


<span class="hljs-comment">// Make this code compile by filling in a value for `shared_numbers` where the</span>
<span class="hljs-comment">// first TODO comment is, and create an initial binding for `child_numbers`</span>
<span class="hljs-comment">// where the second TODO comment is. Try not to create any copies of the `numbers` Vec!</span>
<span class="hljs-comment">// Execute `rustlings hint arc1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-meta">#![forbid(unused_imports)]</span> <span class="hljs-comment">// Do not change this, (or the next) line.</span>
<span class="hljs-keyword">use</span> std::sync::Arc;
<span class="hljs-keyword">use</span> std::thread;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">numbers</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = (<span class="hljs-number">0</span>..<span class="hljs-number">100u32</span>).<span class="hljs-title function_ invoke__">collect</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-variable">shared_numbers</span> = <span class="hljs-comment">// TODO</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">joinhandles</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();

    <span class="hljs-keyword">for</span> <span class="hljs-variable">offset</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">8</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">child_numbers</span> = <span class="hljs-comment">// TODO</span>
        joinhandles.<span class="hljs-title function_ invoke__">push</span>(thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || {
            <span class="hljs-keyword">let</span> <span class="hljs-variable">sum</span>: <span class="hljs-type">u32</span> = child_numbers.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">filter</span>(|&amp;&amp;n| n % <span class="hljs-number">8</span> == offset).<span class="hljs-title function_ invoke__">sum</span>();
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Sum of offset {} is {}&quot;</span>, offset, sum);
        }));
    }
    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> joinhandles.<span class="hljs-title function_ invoke__">into_iter</span>() {
        handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    }
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// box1.rs</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// At compile time, Rust needs to know how much space a type takes up. This becomes problematic</span>
<span class="hljs-comment">// for recursive types, where a value can have as part of itself another value of the same type.</span>
<span class="hljs-comment">// To get around the issue, we can use a `Box` - a smart pointer used to store data on the heap,</span>
<span class="hljs-comment">// which also allows us to wrap a recursive type.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// The recursive type we&#x27;re implementing in this exercise is the `cons list` - a data structure</span>
<span class="hljs-comment">// frequently found in functional programming languages. Each item in a cons list contains two</span>
<span class="hljs-comment">// elements: the value of the current item and the next item. The last item is a value called `Nil`.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Step 1: use a `Box` in the enum definition to make the code compile</span>
<span class="hljs-comment">// Step 2: create both empty and non-empty cons lists by replacing `todo!()`</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Note: the tests should not be changed</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Execute `rustlings hint box1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-meta">#[derive(PartialEq, Debug)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">List</span> {
    <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-type">i32</span>, List),
    Nil,
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;This is an empty cons list: {:?}&quot;</span>, <span class="hljs-title function_ invoke__">create_empty_list</span>());
    <span class="hljs-built_in">println!</span>(
        <span class="hljs-string">&quot;This is a non-empty cons list: {:?}&quot;</span>,
        <span class="hljs-title function_ invoke__">create_non_empty_list</span>()
    );
}

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">create_empty_list</span>() <span class="hljs-punctuation">-&gt;</span> List {
    todo!()
}

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">create_non_empty_list</span>() <span class="hljs-punctuation">-&gt;</span> List {
    todo!()
}

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_create_empty_list</span>() {
        <span class="hljs-built_in">assert_eq!</span>(List::Nil, <span class="hljs-title function_ invoke__">create_empty_list</span>())
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_create_non_empty_list</span>() {
        <span class="hljs-built_in">assert_ne!</span>(<span class="hljs-title function_ invoke__">create_empty_list</span>(), <span class="hljs-title function_ invoke__">create_non_empty_list</span>())
    }
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// cow1.rs</span>

<span class="hljs-comment">// This exercise explores the Cow, or Clone-On-Write type.</span>
<span class="hljs-comment">// Cow is a clone-on-write smart pointer.</span>
<span class="hljs-comment">// It can enclose and provide immutable access to borrowed data, and clone the data lazily when mutation or ownership is required.</span>
<span class="hljs-comment">// The type is designed to work with general borrowed data via the Borrow trait.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// This exercise is meant to show you what to expect when passing data to Cow.</span>
<span class="hljs-comment">// Fix the unit tests by checking for Cow::Owned(_) and Cow::Borrowed(_) at the TODO markers.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">use</span> std::borrow::Cow;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">abs_all</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(input: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> Cow&lt;<span class="hljs-symbol">&#x27;b</span>, [<span class="hljs-type">i32</span>]&gt;) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> Cow&lt;<span class="hljs-symbol">&#x27;b</span>, [<span class="hljs-type">i32</span>]&gt; {
    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..input.<span class="hljs-title function_ invoke__">len</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = input[i];
        <span class="hljs-keyword">if</span> v &lt; <span class="hljs-number">0</span> {
            <span class="hljs-comment">// Clones into a vector if not already owned.</span>
            input.<span class="hljs-title function_ invoke__">to_mut</span>()[i] = -v;
        }
    }
    input
}

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">reference_mutation</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>&gt; {
        <span class="hljs-comment">// Clone occurs because `input` needs to be mutated.</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = [-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>];
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">input</span> = Cow::<span class="hljs-title function_ invoke__">from</span>(&amp;slice[..]);
        <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">abs_all</span>(&amp;<span class="hljs-keyword">mut</span> input) {
            Cow::<span class="hljs-title function_ invoke__">Owned</span>(_) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(()),
            _ =&gt; <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-string">&quot;Expected owned value&quot;</span>),
        }
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">reference_no_mutation</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>&gt; {
        <span class="hljs-comment">// No clone occurs because `input` doesn&#x27;t need to be mutated.</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">input</span> = Cow::<span class="hljs-title function_ invoke__">from</span>(&amp;slice[..]);
        <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">abs_all</span>(&amp;<span class="hljs-keyword">mut</span> input) {
            <span class="hljs-comment">// TODO</span>
        }
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">owned_no_mutation</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>&gt; {
        <span class="hljs-comment">// We can also pass `slice` without `&amp;` so Cow owns it directly.</span>
        <span class="hljs-comment">// In this case no mutation occurs and thus also no clone,</span>
        <span class="hljs-comment">// but the result is still owned because it was never borrowed</span>
        <span class="hljs-comment">// or mutated.</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">input</span> = Cow::<span class="hljs-title function_ invoke__">from</span>(slice);
        <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">abs_all</span>(&amp;<span class="hljs-keyword">mut</span> input) {
            <span class="hljs-comment">// TODO</span>
        }
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">owned_mutation</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>&gt; {
        <span class="hljs-comment">// Of course this is also the case if a mutation does occur.</span>
        <span class="hljs-comment">// In this case the call to `to_mut()` returns a reference to</span>
        <span class="hljs-comment">// the same data as before.</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = <span class="hljs-built_in">vec!</span>[-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>];
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">input</span> = Cow::<span class="hljs-title function_ invoke__">from</span>(slice);
        <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">abs_all</span>(&amp;<span class="hljs-keyword">mut</span> input) {
            <span class="hljs-comment">// TODO</span>
        }
    }
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// rc1.rs</span>
<span class="hljs-comment">// In this exercise, we want to express the concept of multiple owners via the Rc&lt;T&gt; type.</span>
<span class="hljs-comment">// This is a model of our solar system - there is a Sun type and multiple Planets.</span>
<span class="hljs-comment">// The Planets take ownership of the sun, indicating that they revolve around the sun.</span>

<span class="hljs-comment">// Make this code compile by using the proper Rc primitives to express that the sun has multiple owners.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">use</span> std::rc::Rc;

<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sun</span> {}

<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Planet</span> {
    <span class="hljs-title function_ invoke__">Mercury</span>(Rc&lt;Sun&gt;),
    <span class="hljs-title function_ invoke__">Venus</span>(Rc&lt;Sun&gt;),
    <span class="hljs-title function_ invoke__">Earth</span>(Rc&lt;Sun&gt;),
    <span class="hljs-title function_ invoke__">Mars</span>(Rc&lt;Sun&gt;),
    <span class="hljs-title function_ invoke__">Jupiter</span>(Rc&lt;Sun&gt;),
    <span class="hljs-title function_ invoke__">Saturn</span>(Rc&lt;Sun&gt;),
    <span class="hljs-title function_ invoke__">Uranus</span>(Rc&lt;Sun&gt;),
    <span class="hljs-title function_ invoke__">Neptune</span>(Rc&lt;Sun&gt;),
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Planet</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">details</span>(&amp;<span class="hljs-keyword">self</span>) {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hi from {:?}!&quot;</span>, <span class="hljs-keyword">self</span>)
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">sun</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(Sun {});
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;reference count = {}&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;sun)); <span class="hljs-comment">// 1 reference</span>

    <span class="hljs-keyword">let</span> <span class="hljs-variable">mercury</span> = Planet::<span class="hljs-title function_ invoke__">Mercury</span>(Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;sun));
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;reference count = {}&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;sun)); <span class="hljs-comment">// 2 references</span>
    mercury.<span class="hljs-title function_ invoke__">details</span>();

    <span class="hljs-keyword">let</span> <span class="hljs-variable">venus</span> = Planet::<span class="hljs-title function_ invoke__">Venus</span>(Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;sun));
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;reference count = {}&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;sun)); <span class="hljs-comment">// 3 references</span>
    venus.<span class="hljs-title function_ invoke__">details</span>();

    <span class="hljs-keyword">let</span> <span class="hljs-variable">earth</span> = Planet::<span class="hljs-title function_ invoke__">Earth</span>(Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;sun));
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;reference count = {}&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;sun)); <span class="hljs-comment">// 4 references</span>
    earth.<span class="hljs-title function_ invoke__">details</span>();

    <span class="hljs-keyword">let</span> <span class="hljs-variable">mars</span> = Planet::<span class="hljs-title function_ invoke__">Mars</span>(Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;sun));
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;reference count = {}&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;sun)); <span class="hljs-comment">// 5 references</span>
    mars.<span class="hljs-title function_ invoke__">details</span>();

    <span class="hljs-keyword">let</span> <span class="hljs-variable">jupiter</span> = Planet::<span class="hljs-title function_ invoke__">Jupiter</span>(Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;sun));
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;reference count = {}&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;sun)); <span class="hljs-comment">// 6 references</span>
    jupiter.<span class="hljs-title function_ invoke__">details</span>();

    <span class="hljs-comment">// TODO</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">saturn</span> = Planet::<span class="hljs-title function_ invoke__">Saturn</span>(Rc::<span class="hljs-title function_ invoke__">new</span>(Sun {}));
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;reference count = {}&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;sun)); <span class="hljs-comment">// 7 references</span>
    saturn.<span class="hljs-title function_ invoke__">details</span>();

    <span class="hljs-comment">// TODO</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">uranus</span> = Planet::<span class="hljs-title function_ invoke__">Uranus</span>(Rc::<span class="hljs-title function_ invoke__">new</span>(Sun {}));
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;reference count = {}&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;sun)); <span class="hljs-comment">// 8 references</span>
    uranus.<span class="hljs-title function_ invoke__">details</span>();

    <span class="hljs-comment">// TODO</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">neptune</span> = Planet::<span class="hljs-title function_ invoke__">Neptune</span>(Rc::<span class="hljs-title function_ invoke__">new</span>(Sun {}));
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;reference count = {}&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;sun)); <span class="hljs-comment">// 9 references</span>
    neptune.<span class="hljs-title function_ invoke__">details</span>();

    <span class="hljs-built_in">assert_eq!</span>(Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;sun), <span class="hljs-number">9</span>);

    <span class="hljs-title function_ invoke__">drop</span>(neptune);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;reference count = {}&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;sun)); <span class="hljs-comment">// 8 references</span>

    <span class="hljs-title function_ invoke__">drop</span>(uranus);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;reference count = {}&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;sun)); <span class="hljs-comment">// 7 references</span>

    <span class="hljs-title function_ invoke__">drop</span>(saturn);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;reference count = {}&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;sun)); <span class="hljs-comment">// 6 references</span>

    <span class="hljs-title function_ invoke__">drop</span>(jupiter);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;reference count = {}&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;sun)); <span class="hljs-comment">// 5 references</span>

    <span class="hljs-title function_ invoke__">drop</span>(mars);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;reference count = {}&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;sun)); <span class="hljs-comment">// 4 references</span>

    <span class="hljs-comment">// TODO</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;reference count = {}&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;sun)); <span class="hljs-comment">// 3 references</span>

    <span class="hljs-comment">// TODO</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;reference count = {}&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;sun)); <span class="hljs-comment">// 2 references</span>

    <span class="hljs-comment">// TODO</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;reference count = {}&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;sun)); <span class="hljs-comment">// 1 reference</span>

    <span class="hljs-built_in">assert_eq!</span>(Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;sun), <span class="hljs-number">1</span>);
}
</code></pre></p>
</div>
<div class="slide" id="slide_22">
<p><h1 id="macros">Macros</h1>
<p>Rust&#39;s macro system is very powerful, but also kind of difficult to wrap your
head around. We&#39;re not going to teach you how to write your own fully-featured
macros. Instead, we&#39;ll show you how to use and create them.</p>
<p>If you&#39;d like to learn more about writing your own macros, the
<a href="https://github.com/tfpk/macrokata">macrokata</a> project has a similar style
of exercises to Rustlings, but is all about learning to write Macros.</p>
<h2 id="further-information">Further information</h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Macros</a></li>
<li><a href="https://veykril.github.io/tlborm/">The Little Book of Rust Macros</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// macros1.rs</span>
<span class="hljs-comment">// Execute `rustlings hint macros1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-built_in">macro_rules!</span> my_macro {
    () =&gt; {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Check out my macro!&quot;</span>);
    };
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-title function_ invoke__">my_macro</span>();
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// macros2.rs</span>
<span class="hljs-comment">// Execute `rustlings hint macros2` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    my_macro!();
}

<span class="hljs-built_in">macro_rules!</span> my_macro {
    () =&gt; {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Check out my macro!&quot;</span>);
    };
}
</code></pre></p>
</div>
<div class="slide" id="slide_23">
<p><h1 id="clippy">Clippy</h1>
<p>The Clippy tool is a collection of lints to analyze your code so you can catch common mistakes and improve your Rust code.</p>
<p>If you used the installation script for Rustlings, Clippy should be already installed.
If not you can install it manually via <code>rustup component add clippy</code>.</p>
<h2 id="further-information">Further information</h2>
<ul>
<li><a href="https://github.com/rust-lang/rust-clippy">GitHub Repository</a>.</li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// clippy1.rs</span>
<span class="hljs-comment">// The Clippy tool is a collection of lints to analyze your code</span>
<span class="hljs-comment">// so you can catch common mistakes and improve your Rust code.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// For these exercises the code will fail to compile when there are clippy warnings</span>
<span class="hljs-comment">// check clippy&#x27;s suggestions from the output to solve the exercise.</span>
<span class="hljs-comment">// Execute `rustlings hint clippy1` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">use</span> std::<span class="hljs-type">f32</span>;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">pi</span> = <span class="hljs-number">3.14f32</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">radius</span> = <span class="hljs-number">5.00f32</span>;

    <span class="hljs-keyword">let</span> <span class="hljs-variable">area</span> = pi * <span class="hljs-type">f32</span>::<span class="hljs-title function_ invoke__">powi</span>(radius, <span class="hljs-number">2</span>);

    <span class="hljs-built_in">println!</span>(
        <span class="hljs-string">&quot;The area of a circle with radius {:.2} is {:.5}!&quot;</span>,
        radius, area
    )
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// clippy2.rs</span>
<span class="hljs-comment">// Execute `rustlings hint clippy2` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">res</span> = <span class="hljs-number">42</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">option</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">12</span>);
    <span class="hljs-keyword">for</span> <span class="hljs-variable">x</span> <span class="hljs-keyword">in</span> option {
        res += x;
    }
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, res);
}
</code></pre></p>
</div>
<div class="slide" id="slide_24">
<p><h1 id="type-conversions">Type conversions</h1>
<p>Rust offers a multitude of ways to convert a value of a given type into another type.</p>
<p>The simplest form of type conversion is a type cast expression. It is denoted with the binary operator <code>as</code>. For instance, <code>println!(&quot;{}&quot;, 1 + 1.0);</code> would not compile, since <code>1</code> is an integer while <code>1.0</code> is a float. However, <code>println!(&quot;{}&quot;, 1 as f32 + 1.0)</code> should compile. The exercise <a href="using_as.rs"><code>using_as</code></a> tries to cover this.</p>
<p>Rust also offers traits that facilitate type conversions upon implementation. These traits can be found under the <a href="https://doc.rust-lang.org/std/convert/index.html"><code>convert</code></a> module.
The traits are the following:</p>
<ul>
<li><code>From</code> and <code>Into</code> covered in <a href="from_into.rs"><code>from_into</code></a></li>
<li><code>TryFrom</code> and <code>TryInto</code> covered in <a href="try_from_into.rs"><code>try_from_into</code></a></li>
<li><code>AsRef</code> and <code>AsMut</code> covered in <a href="as_ref_mut.rs"><code>as_ref_mut</code></a></li>
</ul>
<p>Furthermore, the <code>std::str</code> module offers a trait called <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a> which helps with converting strings into target types via the <code>parse</code> method on strings. If properly implemented for a given type <code>Person</code>, then <code>let p: Person = &quot;Mark,20&quot;.parse().unwrap()</code> should both compile and run without panicking.</p>
<p>These should be the main ways <em><strong>within the standard library</strong></em> to convert data into your desired types.</p>
<h2 id="further-information">Further information</h2>
<p>These are not directly covered in the book, but the standard library has a great documentation for it.</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/convert/index.html">conversions</a></li>
<li><a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code> trait</a></li>
</ul>

<pre><code class="language-rs"><span class="hljs-comment">// AsRef and AsMut allow for cheap reference-to-reference conversions.</span>
<span class="hljs-comment">// Read more about them at https://doc.rust-lang.org/std/convert/trait.AsRef.html</span>
<span class="hljs-comment">// and https://doc.rust-lang.org/std/convert/trait.AsMut.html, respectively.</span>
<span class="hljs-comment">// Execute `rustlings hint as_ref_mut` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-comment">// Obtain the number of bytes (not characters) in the given argument.</span>
<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Add the AsRef trait appropriately as a trait bound.</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">byte_counter</span>&lt;T&gt;(arg: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> {
    arg.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">as_bytes</span>().<span class="hljs-title function_ invoke__">len</span>()
}

<span class="hljs-comment">// Obtain the number of characters (not bytes) in the given argument.</span>
<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Add the AsRef trait appropriately as a trait bound.</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">char_counter</span>&lt;T&gt;(arg: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> {
    arg.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">count</span>()
}

<span class="hljs-comment">// Squares a number using as_mut().</span>
<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Add the appropriate trait bound.</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">num_sq</span>&lt;T&gt;(arg: &amp;<span class="hljs-keyword">mut</span> T) {
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement the function body.</span>
    ???
}

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">different_counts</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;Caf√© au lait&quot;</span>;
        <span class="hljs-built_in">assert_ne!</span>(<span class="hljs-title function_ invoke__">char_counter</span>(s), <span class="hljs-title function_ invoke__">byte_counter</span>(s));
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">same_counts</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;Cafe au lait&quot;</span>;
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">char_counter</span>(s), <span class="hljs-title function_ invoke__">byte_counter</span>(s));
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">different_counts_using_string</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Caf√© au lait&quot;</span>);
        <span class="hljs-built_in">assert_ne!</span>(<span class="hljs-title function_ invoke__">char_counter</span>(s.<span class="hljs-title function_ invoke__">clone</span>()), <span class="hljs-title function_ invoke__">byte_counter</span>(s));
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">same_counts_using_string</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Cafe au lait&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">char_counter</span>(s.<span class="hljs-title function_ invoke__">clone</span>()), <span class="hljs-title function_ invoke__">byte_counter</span>(s));
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">mult_box</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-type">u32</span>&gt; = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3</span>);
        <span class="hljs-title function_ invoke__">num_sq</span>(&amp;<span class="hljs-keyword">mut</span> num);
        <span class="hljs-built_in">assert_eq!</span>(*num, <span class="hljs-number">9</span>);
    }
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// The From trait is used for value-to-value conversions.</span>
<span class="hljs-comment">// If From is implemented correctly for a type, the Into trait should work conversely.</span>
<span class="hljs-comment">// You can read more about it at https://doc.rust-lang.org/std/convert/trait.From.html</span>
<span class="hljs-comment">// Execute `rustlings hint from_into` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> {
    name: <span class="hljs-type">String</span>,
    age: <span class="hljs-type">usize</span>,
}

<span class="hljs-comment">// We implement the Default trait to use it as a fallback</span>
<span class="hljs-comment">// when the provided string is not convertible into a Person object</span>
<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Default</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">default</span>() <span class="hljs-punctuation">-&gt;</span> Person {
        Person {
            name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;John&quot;</span>),
            age: <span class="hljs-number">30</span>,
        }
    }
}

<span class="hljs-comment">// Your task is to complete this implementation</span>
<span class="hljs-comment">// in order for the line `let p = Person::from(&quot;Mark,20&quot;)` to compile</span>
<span class="hljs-comment">// Please note that you&#x27;ll need to parse the age component into a `usize`</span>
<span class="hljs-comment">// with something like `&quot;4&quot;.parse::&lt;usize&gt;()`. The outcome of this needs to</span>
<span class="hljs-comment">// be handled appropriately.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Steps:</span>
<span class="hljs-comment">// 1. If the length of the provided string is 0, then return the default of Person</span>
<span class="hljs-comment">// 2. Split the given string on the commas present in it</span>
<span class="hljs-comment">// 3. Extract the first element from the split operation and use it as the name</span>
<span class="hljs-comment">// 4. If the name is empty, then return the default of Person</span>
<span class="hljs-comment">// 5. Extract the other element from the split operation and parse it into a `usize` as the age</span>
<span class="hljs-comment">// If while parsing the age, something goes wrong, then return the default of Person</span>
<span class="hljs-comment">// Otherwise, then return an instantiated Person object with the results</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;&amp;<span class="hljs-type">str</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> Person {
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-comment">// Use the `from` function</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = Person::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Mark,20&quot;</span>);
    <span class="hljs-comment">// Since From is implemented for Person, we should be able to use Into</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">p2</span>: Person = <span class="hljs-string">&quot;Gerald,70&quot;</span>.<span class="hljs-title function_ invoke__">into</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{:?}&quot;</span>, p1);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{:?}&quot;</span>, p2);
}

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_default</span>() {
        <span class="hljs-comment">// Test that the default person is 30 year old John</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">dp</span> = Person::<span class="hljs-title function_ invoke__">default</span>();
        <span class="hljs-built_in">assert_eq!</span>(dp.name, <span class="hljs-string">&quot;John&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(dp.age, <span class="hljs-number">30</span>);
    }
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_bad_convert</span>() {
        <span class="hljs-comment">// Test that John is returned when bad string is provided</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = Person::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.name, <span class="hljs-string">&quot;John&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.age, <span class="hljs-number">30</span>);
    }
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_good_convert</span>() {
        <span class="hljs-comment">// Test that &quot;Mark,20&quot; works</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = Person::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Mark,20&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.name, <span class="hljs-string">&quot;Mark&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.age, <span class="hljs-number">20</span>);
    }
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_bad_age</span>() {
        <span class="hljs-comment">// Test that &quot;Mark,twenty&quot; will return the default person due to an error in parsing age</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = Person::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Mark,twenty&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.name, <span class="hljs-string">&quot;John&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.age, <span class="hljs-number">30</span>);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_missing_comma_and_age</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span>: Person = Person::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Mark&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.name, <span class="hljs-string">&quot;John&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.age, <span class="hljs-number">30</span>);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_missing_age</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span>: Person = Person::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Mark,&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.name, <span class="hljs-string">&quot;John&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.age, <span class="hljs-number">30</span>);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_missing_name</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span>: Person = Person::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;,1&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.name, <span class="hljs-string">&quot;John&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.age, <span class="hljs-number">30</span>);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_missing_name_and_age</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span>: Person = Person::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;,&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.name, <span class="hljs-string">&quot;John&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.age, <span class="hljs-number">30</span>);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_missing_name_and_invalid_age</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span>: Person = Person::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;,one&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.name, <span class="hljs-string">&quot;John&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.age, <span class="hljs-number">30</span>);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_trailing_comma</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span>: Person = Person::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Mike,32,&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.name, <span class="hljs-string">&quot;John&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.age, <span class="hljs-number">30</span>);
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_trailing_comma_and_some_string</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span>: Person = Person::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Mike,32,man&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.name, <span class="hljs-string">&quot;John&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.age, <span class="hljs-number">30</span>);
    }
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// from_str.rs</span>
<span class="hljs-comment">// This is similar to from_into.rs, but this time we&#x27;ll implement `FromStr`</span>
<span class="hljs-comment">// and return errors instead of falling back to a default value.</span>
<span class="hljs-comment">// Additionally, upon implementing FromStr, you can use the `parse` method</span>
<span class="hljs-comment">// on strings to generate an object of the implementor type.</span>
<span class="hljs-comment">// You can read more about it at https://doc.rust-lang.org/std/str/trait.FromStr.html</span>
<span class="hljs-comment">// Execute `rustlings hint from_str` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-keyword">use</span> std::num::ParseIntError;
<span class="hljs-keyword">use</span> std::<span class="hljs-type">str</span>::FromStr;

<span class="hljs-meta">#[derive(Debug, PartialEq)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> {
    name: <span class="hljs-type">String</span>,
    age: <span class="hljs-type">usize</span>,
}

<span class="hljs-comment">// We will use this error type for the `FromStr` implementation.</span>
<span class="hljs-meta">#[derive(Debug, PartialEq)]</span>
<span class="hljs-keyword">enum</span> <span class="hljs-title class_">ParsePersonError</span> {
    <span class="hljs-comment">// Empty input string</span>
    Empty,
    <span class="hljs-comment">// Incorrect number of fields</span>
    BadLen,
    <span class="hljs-comment">// Empty name field</span>
    NoName,
    <span class="hljs-comment">// Wrapped error from parse::&lt;usize&gt;()</span>
    <span class="hljs-title function_ invoke__">ParseInt</span>(ParseIntError),
}

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-comment">// Steps:</span>
<span class="hljs-comment">// 1. If the length of the provided string is 0, an error should be returned</span>
<span class="hljs-comment">// 2. Split the given string on the commas present in it</span>
<span class="hljs-comment">// 3. Only 2 elements should be returned from the split, otherwise return an error</span>
<span class="hljs-comment">// 4. Extract the first element from the split operation and use it as the name</span>
<span class="hljs-comment">// 5. Extract the other element from the split operation and parse it into a `usize` as the age</span>
<span class="hljs-comment">//    with something like `&quot;4&quot;.parse::&lt;usize&gt;()`</span>
<span class="hljs-comment">// 6. If while extracting the name and the age something goes wrong, an error should be returned</span>
<span class="hljs-comment">// If everything goes well, then return a Result of a Person object</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// As an aside: `Box&lt;dyn Error&gt;` implements `From&lt;&amp;&#x27;_ str&gt;`. This means that if you want to return a</span>
<span class="hljs-comment">// string error message, you can do so via just using return `Err(&quot;my error message&quot;.into())`.</span>

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">FromStr</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Err</span> = ParsePersonError;
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_str</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;Person, <span class="hljs-keyword">Self</span>::<span class="hljs-literal">Err</span>&gt; {
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = <span class="hljs-string">&quot;Mark,20&quot;</span>.parse::&lt;Person&gt;().<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{:?}&quot;</span>, p);
}

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">empty_input</span>() {
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-string">&quot;&quot;</span>.parse::&lt;Person&gt;(), <span class="hljs-title function_ invoke__">Err</span>(ParsePersonError::Empty));
    }
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">good_input</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = <span class="hljs-string">&quot;John,32&quot;</span>.parse::&lt;Person&gt;();
        <span class="hljs-built_in">assert!</span>(p.<span class="hljs-title function_ invoke__">is_ok</span>());
        <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = p.<span class="hljs-title function_ invoke__">unwrap</span>();
        <span class="hljs-built_in">assert_eq!</span>(p.name, <span class="hljs-string">&quot;John&quot;</span>);
        <span class="hljs-built_in">assert_eq!</span>(p.age, <span class="hljs-number">32</span>);
    }
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">missing_age</span>() {
        <span class="hljs-built_in">assert!</span>(matches!(
            <span class="hljs-string">&quot;John,&quot;</span>.parse::&lt;Person&gt;(),
            <span class="hljs-title function_ invoke__">Err</span>(ParsePersonError::<span class="hljs-title function_ invoke__">ParseInt</span>(_))
        ));
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">invalid_age</span>() {
        <span class="hljs-built_in">assert!</span>(matches!(
            <span class="hljs-string">&quot;John,twenty&quot;</span>.parse::&lt;Person&gt;(),
            <span class="hljs-title function_ invoke__">Err</span>(ParsePersonError::<span class="hljs-title function_ invoke__">ParseInt</span>(_))
        ));
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">missing_comma_and_age</span>() {
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-string">&quot;John&quot;</span>.parse::&lt;Person&gt;(), <span class="hljs-title function_ invoke__">Err</span>(ParsePersonError::BadLen));
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">missing_name</span>() {
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-string">&quot;,1&quot;</span>.parse::&lt;Person&gt;(), <span class="hljs-title function_ invoke__">Err</span>(ParsePersonError::NoName));
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">missing_name_and_age</span>() {
        <span class="hljs-built_in">assert!</span>(matches!(
            <span class="hljs-string">&quot;,&quot;</span>.parse::&lt;Person&gt;(),
            <span class="hljs-title function_ invoke__">Err</span>(ParsePersonError::NoName | ParsePersonError::<span class="hljs-title function_ invoke__">ParseInt</span>(_))
        ));
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">missing_name_and_invalid_age</span>() {
        <span class="hljs-built_in">assert!</span>(matches!(
            <span class="hljs-string">&quot;,one&quot;</span>.parse::&lt;Person&gt;(),
            <span class="hljs-title function_ invoke__">Err</span>(ParsePersonError::NoName | ParsePersonError::<span class="hljs-title function_ invoke__">ParseInt</span>(_))
        ));
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">trailing_comma</span>() {
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-string">&quot;John,32,&quot;</span>.parse::&lt;Person&gt;(), <span class="hljs-title function_ invoke__">Err</span>(ParsePersonError::BadLen));
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">trailing_comma_and_some_string</span>() {
        <span class="hljs-built_in">assert_eq!</span>(
            <span class="hljs-string">&quot;John,32,man&quot;</span>.parse::&lt;Person&gt;(),
            <span class="hljs-title function_ invoke__">Err</span>(ParsePersonError::BadLen)
        );
    }
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// try_from_into.rs</span>
<span class="hljs-comment">// TryFrom is a simple and safe type conversion that may fail in a controlled way under some circumstances.</span>
<span class="hljs-comment">// Basically, this is the same as From. The main difference is that this should return a Result type</span>
<span class="hljs-comment">// instead of the target type itself.</span>
<span class="hljs-comment">// You can read more about it at https://doc.rust-lang.org/std/convert/trait.TryFrom.html</span>
<span class="hljs-comment">// Execute `rustlings hint try_from_into` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-keyword">use</span> std::convert::{TryFrom, TryInto};

<span class="hljs-meta">#[derive(Debug, PartialEq)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Color</span> {
    red: <span class="hljs-type">u8</span>,
    green: <span class="hljs-type">u8</span>,
    blue: <span class="hljs-type">u8</span>,
}

<span class="hljs-comment">// We will use this error type for these `TryFrom` conversions.</span>
<span class="hljs-meta">#[derive(Debug, PartialEq)]</span>
<span class="hljs-keyword">enum</span> <span class="hljs-title class_">IntoColorError</span> {
    <span class="hljs-comment">// Incorrect length of slice</span>
    BadLen,
    <span class="hljs-comment">// Integer conversion error</span>
    IntConversion,
}

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-comment">// Your task is to complete this implementation</span>
<span class="hljs-comment">// and return an Ok result of inner type Color.</span>
<span class="hljs-comment">// You need to create an implementation for a tuple of three integers,</span>
<span class="hljs-comment">// an array of three integers, and a slice of integers.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Note that the implementation for tuple and array will be checked at compile time,</span>
<span class="hljs-comment">// but the slice implementation needs to check the slice length!</span>
<span class="hljs-comment">// Also note that correct RGB color values must be integers in the 0..=255 range.</span>

<span class="hljs-comment">// Tuple implementation</span>
<span class="hljs-keyword">impl</span> <span class="hljs-title class_">TryFrom</span>&lt;(<span class="hljs-type">i16</span>, <span class="hljs-type">i16</span>, <span class="hljs-type">i16</span>)&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Color</span> {
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Error</span> = IntoColorError;
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">try_from</span>(tuple: (<span class="hljs-type">i16</span>, <span class="hljs-type">i16</span>, <span class="hljs-type">i16</span>)) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-keyword">Self</span>, <span class="hljs-keyword">Self</span>::Error&gt; {
    }
}

<span class="hljs-comment">// Array implementation</span>
<span class="hljs-keyword">impl</span> <span class="hljs-title class_">TryFrom</span>&lt;[<span class="hljs-type">i16</span>; <span class="hljs-number">3</span>]&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Color</span> {
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Error</span> = IntoColorError;
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">try_from</span>(arr: [<span class="hljs-type">i16</span>; <span class="hljs-number">3</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-keyword">Self</span>, <span class="hljs-keyword">Self</span>::Error&gt; {
    }
}

<span class="hljs-comment">// Slice implementation</span>
<span class="hljs-keyword">impl</span> <span class="hljs-title class_">TryFrom</span>&lt;&amp;[<span class="hljs-type">i16</span>]&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Color</span> {
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Error</span> = IntoColorError;
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">try_from</span>(slice: &amp;[<span class="hljs-type">i16</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-keyword">Self</span>, <span class="hljs-keyword">Self</span>::Error&gt; {
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-comment">// Use the `try_from` function</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">c1</span> = Color::<span class="hljs-title function_ invoke__">try_from</span>((<span class="hljs-number">183</span>, <span class="hljs-number">65</span>, <span class="hljs-number">14</span>));
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{:?}&quot;</span>, c1);

    <span class="hljs-comment">// Since TryFrom is implemented for Color, we should be able to use TryInto</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">c2</span>: <span class="hljs-type">Result</span>&lt;Color, _&gt; = [<span class="hljs-number">183</span>, <span class="hljs-number">65</span>, <span class="hljs-number">14</span>].<span class="hljs-title function_ invoke__">try_into</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{:?}&quot;</span>, c2);

    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">183</span>, <span class="hljs-number">65</span>, <span class="hljs-number">14</span>];
    <span class="hljs-comment">// With slice we should use `try_from` function</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">c3</span> = Color::<span class="hljs-title function_ invoke__">try_from</span>(&amp;v[..]);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{:?}&quot;</span>, c3);
    <span class="hljs-comment">// or take slice within round brackets and use TryInto</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">c4</span>: <span class="hljs-type">Result</span>&lt;Color, _&gt; = (&amp;v[..]).<span class="hljs-title function_ invoke__">try_into</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{:?}&quot;</span>, c4);
}

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_tuple_out_of_range_positive</span>() {
        <span class="hljs-built_in">assert_eq!</span>(
            Color::<span class="hljs-title function_ invoke__">try_from</span>((<span class="hljs-number">256</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">10000</span>)),
            <span class="hljs-title function_ invoke__">Err</span>(IntoColorError::IntConversion)
        );
    }
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_tuple_out_of_range_negative</span>() {
        <span class="hljs-built_in">assert_eq!</span>(
            Color::<span class="hljs-title function_ invoke__">try_from</span>((-<span class="hljs-number">1</span>, -<span class="hljs-number">10</span>, -<span class="hljs-number">256</span>)),
            <span class="hljs-title function_ invoke__">Err</span>(IntoColorError::IntConversion)
        );
    }
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_tuple_sum</span>() {
        <span class="hljs-built_in">assert_eq!</span>(
            Color::<span class="hljs-title function_ invoke__">try_from</span>((-<span class="hljs-number">1</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>)),
            <span class="hljs-title function_ invoke__">Err</span>(IntoColorError::IntConversion)
        );
    }
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_tuple_correct</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span>: <span class="hljs-type">Result</span>&lt;Color, _&gt; = (<span class="hljs-number">183</span>, <span class="hljs-number">65</span>, <span class="hljs-number">14</span>).<span class="hljs-title function_ invoke__">try_into</span>();
        <span class="hljs-built_in">assert!</span>(c.<span class="hljs-title function_ invoke__">is_ok</span>());
        <span class="hljs-built_in">assert_eq!</span>(
            c.<span class="hljs-title function_ invoke__">unwrap</span>(),
            Color {
                red: <span class="hljs-number">183</span>,
                green: <span class="hljs-number">65</span>,
                blue: <span class="hljs-number">14</span>
            }
        );
    }
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_array_out_of_range_positive</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span>: <span class="hljs-type">Result</span>&lt;Color, _&gt; = [<span class="hljs-number">1000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">256</span>].<span class="hljs-title function_ invoke__">try_into</span>();
        <span class="hljs-built_in">assert_eq!</span>(c, <span class="hljs-title function_ invoke__">Err</span>(IntoColorError::IntConversion));
    }
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_array_out_of_range_negative</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span>: <span class="hljs-type">Result</span>&lt;Color, _&gt; = [-<span class="hljs-number">10</span>, -<span class="hljs-number">256</span>, -<span class="hljs-number">1</span>].<span class="hljs-title function_ invoke__">try_into</span>();
        <span class="hljs-built_in">assert_eq!</span>(c, <span class="hljs-title function_ invoke__">Err</span>(IntoColorError::IntConversion));
    }
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_array_sum</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span>: <span class="hljs-type">Result</span>&lt;Color, _&gt; = [-<span class="hljs-number">1</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>].<span class="hljs-title function_ invoke__">try_into</span>();
        <span class="hljs-built_in">assert_eq!</span>(c, <span class="hljs-title function_ invoke__">Err</span>(IntoColorError::IntConversion));
    }
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_array_correct</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span>: <span class="hljs-type">Result</span>&lt;Color, _&gt; = [<span class="hljs-number">183</span>, <span class="hljs-number">65</span>, <span class="hljs-number">14</span>].<span class="hljs-title function_ invoke__">try_into</span>();
        <span class="hljs-built_in">assert!</span>(c.<span class="hljs-title function_ invoke__">is_ok</span>());
        <span class="hljs-built_in">assert_eq!</span>(
            c.<span class="hljs-title function_ invoke__">unwrap</span>(),
            Color {
                red: <span class="hljs-number">183</span>,
                green: <span class="hljs-number">65</span>,
                blue: <span class="hljs-number">14</span>
            }
        );
    }
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_slice_out_of_range_positive</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = [<span class="hljs-number">10000</span>, <span class="hljs-number">256</span>, <span class="hljs-number">1000</span>];
        <span class="hljs-built_in">assert_eq!</span>(
            Color::<span class="hljs-title function_ invoke__">try_from</span>(&amp;arr[..]),
            <span class="hljs-title function_ invoke__">Err</span>(IntoColorError::IntConversion)
        );
    }
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_slice_out_of_range_negative</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = [-<span class="hljs-number">256</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">10</span>];
        <span class="hljs-built_in">assert_eq!</span>(
            Color::<span class="hljs-title function_ invoke__">try_from</span>(&amp;arr[..]),
            <span class="hljs-title function_ invoke__">Err</span>(IntoColorError::IntConversion)
        );
    }
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_slice_sum</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = [-<span class="hljs-number">1</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>];
        <span class="hljs-built_in">assert_eq!</span>(
            Color::<span class="hljs-title function_ invoke__">try_from</span>(&amp;arr[..]),
            <span class="hljs-title function_ invoke__">Err</span>(IntoColorError::IntConversion)
        );
    }
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_slice_correct</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">183</span>, <span class="hljs-number">65</span>, <span class="hljs-number">14</span>];
        <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span>: <span class="hljs-type">Result</span>&lt;Color, _&gt; = Color::<span class="hljs-title function_ invoke__">try_from</span>(&amp;v[..]);
        <span class="hljs-built_in">assert!</span>(c.<span class="hljs-title function_ invoke__">is_ok</span>());
        <span class="hljs-built_in">assert_eq!</span>(
            c.<span class="hljs-title function_ invoke__">unwrap</span>(),
            Color {
                red: <span class="hljs-number">183</span>,
                green: <span class="hljs-number">65</span>,
                blue: <span class="hljs-number">14</span>
            }
        );
    }
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_slice_excess_length</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];
        <span class="hljs-built_in">assert_eq!</span>(Color::<span class="hljs-title function_ invoke__">try_from</span>(&amp;v[..]), <span class="hljs-title function_ invoke__">Err</span>(IntoColorError::BadLen));
    }
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_slice_insufficient_length</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>];
        <span class="hljs-built_in">assert_eq!</span>(Color::<span class="hljs-title function_ invoke__">try_from</span>(&amp;v[..]), <span class="hljs-title function_ invoke__">Err</span>(IntoColorError::BadLen));
    }
}
</code></pre>
<pre><code class="language-rs"><span class="hljs-comment">// Type casting in Rust is done via the usage of the `as` operator.</span>
<span class="hljs-comment">// Please note that the `as` operator is not only used when type casting.</span>
<span class="hljs-comment">// It also helps with renaming imports.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// The goal is to make sure that the division does not fail to compile</span>
<span class="hljs-comment">// and returns the proper type.</span>
<span class="hljs-comment">// Execute `rustlings hint using_as` or use the `hint` watch subcommand for a hint.</span>

<span class="hljs-comment">// I AM NOT DONE</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">average</span>(values: &amp;[<span class="hljs-type">f64</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">total</span> = values.<span class="hljs-title function_ invoke__">iter</span>().sum::&lt;<span class="hljs-type">f64</span>&gt;();
    total / values.<span class="hljs-title function_ invoke__">len</span>()
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">values</span> = [<span class="hljs-number">3.5</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">13.0</span>, <span class="hljs-number">11.7</span>];
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, <span class="hljs-title function_ invoke__">average</span>(&amp;values));
}

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">returns_proper_type_and_value</span>() {
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">average</span>(&amp;[<span class="hljs-number">3.5</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">13.0</span>, <span class="hljs-number">11.7</span>]), <span class="hljs-number">7.125</span>);
    }
}
</code></pre></p>
</div>
<div class="slide" id="slide_25">
<h1 id="thanks-to-all-contributors-of-rustlings">Thanks to all contributors of <a href="https://github.com/rust-lang/rustlings">rustlings</a>!</h1>
<p>See other CodeSlide CLI examples <a href="https://github.com/AsherJingkongChen/codeslide/tree/main/applications/cli/examples">here</a></p>
<p>See the installation guide of CodeSlide CLI <a href="https://github.com/AsherJingkongChen/codeslide/tree/main/applications/cli/README.md#installation">here</a></p>
</div>
</div>
</body>
</html>
